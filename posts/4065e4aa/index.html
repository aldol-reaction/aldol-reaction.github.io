<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"aldol-reaction.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="练习14.3：string和vector都定义了重载的&#x3D;&#x3D;以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的&#x3D;&#x3D;？(a) 应用了C++语言内置版本的&#x3D;&#x3D;，比较两个指针。"><meta property="og:type" content="article"><meta property="og:title" content="cppprimer第十四章"><meta property="og:url" content="https://aldol-reaction.github.io/posts/4065e4aa/index.html"><meta property="og:site_name" content="aldol_reaction"><meta property="og:description" content="练习14.3：string和vector都定义了重载的&#x3D;&#x3D;以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的&#x3D;&#x3D;？(a) 应用了C++语言内置版本的&#x3D;&#x3D;，比较两个指针。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-09-29T11:26:57.000Z"><meta property="article:modified_time" content="2022-10-06T03:40:13.143Z"><meta property="article:author" content="aldol_reaction"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://aldol-reaction.github.io/posts/4065e4aa/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://aldol-reaction.github.io/posts/4065e4aa/","path":"posts/4065e4aa/","title":"cppprimer第十四章"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>cppprimer第十四章 | aldol_reaction</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-K48RCS59KP"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-K48RCS59KP","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?70a587710ee6d5e2204e4c01e7b0468c"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">aldol_reaction</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A014.3string%E5%92%8Cvector%E9%83%BD%E5%AE%9A%E4%B9%89%E4%BA%86%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BB%A5%E6%AF%94%E8%BE%83%E5%90%84%E8%87%AA%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%81%87%E8%AE%BEsvec1%E5%92%8Csvec2%E6%98%AF%E5%AD%98%E6%94%BEstring%E7%9A%84vector%E7%A1%AE%E5%AE%9A%E5%9C%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84a-%E5%BA%94%E7%94%A8%E4%BA%86c%E8%AF%AD%E8%A8%80%E5%86%85%E7%BD%AE%E7%89%88%E6%9C%AC%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">练习14.3：string和vector都定义了重载的&#x3D;&#x3D;以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的&#x3D;&#x3D;？(a) 应用了C++语言内置版本的&#x3D;&#x3D;，比较两个指针。</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number"></span> <span class="nav-text">第十四章 重载运算与类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number"></span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">输入和输出运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">重载输出运算符&lt;&lt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">重载输入运算符&gt;&gt;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-"><span class="nav-number"></span> <span class="nav-text">算数和关系运算符（+、-、*、&#x2F;）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">相等运算符&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">关系运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">赋值运算符&#x3D;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">下标运算符[]</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6--"><span class="nav-number"></span> <span class="nav-text">递增和递减运算符（++、--）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6-"><span class="nav-number"></span> <span class="nav-text">成员访问运算符（*、-&gt;）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">函数调用运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E6%98%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">lambda是函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">标准库定义的函数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8Efunction"><span class="nav-number"></span> <span class="nav-text">可调用对象与function</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">重载、类型转换、运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">类型转换运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%9C%89%E4%BA%8C%E4%B9%89%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number"></span> <span class="nav-text">避免有二义性的类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D%E4%B8%8E%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number"></span> <span class="nav-text">函数匹配与重载运算符</span></a></li></ol></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="aldol_reaction" src="/images/blogpic.png"><p class="site-author-name" itemprop="name">aldol_reaction</p><div class="site-description" itemprop="description">while(!Success()) Try();</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友链</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://nexuslbh.top/" title="http:&#x2F;&#x2F;nexuslbh.top&#x2F;" rel="noopener" target="_blank">Bohan Liu</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aldol-reaction.github.io/posts/4065e4aa/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/blogpic.png"><meta itemprop="name" content="aldol_reaction"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="aldol_reaction"><meta itemprop="description" content="while(!Success()) Try();"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="cppprimer第十四章 | aldol_reaction"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">cppprimer第十四章</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-09-29 19:26:57" itemprop="dateCreated datePublished" datetime="2022-09-29T19:26:57+08:00">2022-09-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-10-06 11:40:13" itemprop="dateModified" datetime="2022-10-06T11:40:13+08:00">2022-10-06</time> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h4 id="练习14.3string和vector都定义了重载的以比较各自的对象假设svec1和svec2是存放string的vector确定在下面的表达式中分别使用了哪个版本的a-应用了c语言内置版本的比较两个指针">练习14.3：string和vector都定义了重载的==以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的==？(a) 应用了C++语言内置版本的==，比较两个指针。</h4><span id="more"></span><h1 id="第十四章-重载运算与类型转换">第十四章 重载运算与类型转换</h1><h2 id="基本概念">基本概念</h2><ul><li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li><li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li><li>只能重载大多数的运算符，而不能发明新的运算符号。</li><li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li><li>是否是成员函数：<ul><li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li><li>复合赋值运算符一般来说是成员。</li><li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li><li>具有对称性的运算符如算术、相等性、关系、输入输出和位运算符等，通常是非成员函数。</li></ul></li></ul><p><strong>运算符</strong>:</p><table><colgroup><col style="width:68%"><col style="width:31%"></colgroup><thead><tr class="header"><th>可以被重载</th><th>不可以被重载</th></tr></thead><tbody><tr class="odd"><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code></td><td><code>::</code>, <code>.*</code>, <code>.</code>, <code>? :</code>,</td></tr><tr class="even"><td><code>&amp;</code>, <code>|</code>, <code>~</code>, <code>!</code>, <code>,</code>, <code>=</code></td><td></td></tr><tr class="odd"><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>++</code>, <code>--</code></td><td></td></tr><tr class="even"><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>, <code>!=</code>, <code>&amp;&amp;</code>, <code>||</code></td><td></td></tr><tr class="odd"><td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>, <code>^=</code>, <code>&amp;=</code></td><td></td></tr><tr class="even"><td>|=, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>[]</code>, <code>()</code></td><td></td></tr><tr class="odd"><td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>, <code>new[]</code>, <code>delete</code>, <code>delete[]</code></td><td></td></tr></tbody></table><h2 id="输入和输出运算符">输入和输出运算符</h2><h3 id="重载输出运算符">重载输出运算符&lt;&lt;</h3><ul><li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li><li>输入输出运算符必须是非成员函数。</li></ul><h3 id="重载输入运算符">重载输入运算符&gt;&gt;</h3><ul><li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li><li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li></ul><h2 id="算数和关系运算符-">算数和关系运算符（+、-、*、/）</h2><ul><li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li></ul><h3 id="相等运算符">相等运算符==</h3><ul><li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li><li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li><li>相等运算符应该具有传递性。</li><li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li></ul><h3 id="关系运算符">关系运算符</h3><ul><li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且仅当<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符。</li></ul><h2 id="赋值运算符">赋值运算符=</h2><ul><li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li><li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li></ul><h2 id="下标运算符">下标运算符[]</h2><ul><li>下标运算符必须是成员函数。</li><li>一般会定义两个版本：<ul><li>1.返回普通引用。</li><li>2.类的常量成员，并返回常量引用。</li></ul></li></ul><h2 id="递增和递减运算符--">递增和递减运算符（++、--）</h2><ul><li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li><li>通常应该被定义成类的成员。</li><li>前置运算符应该返回递增或递减后对象的引用。</li><li>后置运算符应该返回递增或递减前对象的值，而不是引用。</li><li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li></ul><h2 id="成员访问运算符-">成员访问运算符（*、-&gt;）</h2><ul><li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li><li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li><li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li></ul><h2 id="函数调用运算符">函数调用运算符</h2><ul><li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li><li>函数调用运算符必须是成员函数。</li><li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li><li>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li></ul><h3 id="lambda是函数对象"><code>lambda</code>是函数对象</h3><ul><li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li></ul><h3 id="标准库定义的函数对象">标准库定义的函数对象</h3><p><strong>标准库函数对象</strong>:</p><table><thead><tr class="header"><th>算术</th><th>关系</th><th>逻辑</th></tr></thead><tbody><tr class="odd"><td><code>plus&lt;Type&gt;</code></td><td><code>equal_to&lt;Type&gt;</code></td><td><code>logical_and&lt;Type&gt;</code></td></tr><tr class="even"><td><code>minus&lt;Type&gt;</code></td><td><code>not_equal_to&lt;Type&gt;</code></td><td><code>logical_or&lt;Type&gt;</code></td></tr><tr class="odd"><td><code>multiplies&lt;Type&gt;</code></td><td><code>greater&lt;Type&gt;</code></td><td><code>logical_not&lt;Type&gt;</code></td></tr><tr class="even"><td><code>divides&lt;Type&gt;</code></td><td><code>greater_equal&lt;Type&gt;</code></td><td></td></tr><tr class="odd"><td><code>modulus&lt;Type&gt;</code></td><td><code>less&lt;Type&gt;</code></td><td></td></tr><tr class="even"><td><code>negate&lt;Type&gt;</code></td><td><code>less_equal&lt;Type&gt;</code></td><td></td></tr></tbody></table><ul><li>可以在算法中使用标准库函数对象。</li></ul><h3 id="可调用对象与function">可调用对象与function</h3><p><strong>标准库function类型</strong>：</p><table><colgroup><col style="width:34%"><col style="width:65%"></colgroup><thead><tr class="header"><th>操作</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>function&lt;T&gt; f;</code></td><td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td></tr><tr class="even"><td><code>function&lt;T&gt; f(nullptr);</code></td><td>显式地构造一个空<code>function</code></td></tr><tr class="odd"><td><code>function&lt;T&gt; f(obj)</code></td><td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td></tr><tr class="even"><td><code>f</code></td><td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td></tr><tr class="odd"><td>定义为<code>function&lt;T&gt;</code>的成员的类型</td><td></td></tr><tr class="even"><td><code>result_type</code></td><td>该<code>function</code>类型的可调用对象返回的类型</td></tr><tr class="odd"><td><code>argument_type</code></td><td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td></tr><tr class="even"><td><code>first_argument_type</code></td><td>第一个实参的类型</td></tr><tr class="odd"><td><code>second_argument_type</code></td><td>第二个实参的类型</td></tr></tbody></table><ul><li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li></ul><h2 id="重载类型转换运算符">重载、类型转换、运算符</h2><h3 id="类型转换运算符">类型转换运算符</h3><ul><li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></li><li>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</li><li>避免过度使用类型转换函数。</li><li>C++11引入了显式的类型转换运算符。</li><li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li></ul><h3 id="避免有二义性的类型转换">避免有二义性的类型转换</h3><ul><li>通常，不要为类第几个亿相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。</li><li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</li></ul><h3 id="函数匹配与重载运算符">函数匹配与重载运算符</h3><ul><li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：<ul><li><code>a.operatorsym(b);</code></li><li><code>operatorsym(a,b);</code></li></ul></li><li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/ba565e9d/" rel="prev" title="cppprimer第十二章"><i class="fa fa-chevron-left"></i> cppprimer第十二章</a></div><div class="post-nav-item"><a href="/posts/0/" rel="next"><i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NjgzNC8zMzI5OA"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">aldol_reaction</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">77k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:10</span></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv">本站访客数 <span id="busuanzi_value_site_uv"></span> 人 | <span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span><div class="run_time" style="text-align:center"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("07/10/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div></span></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="/js/third-party/comments/livere.js"></script></body></html>