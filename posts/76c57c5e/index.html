<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"aldol-reaction.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="第7章 类"><meta property="og:type" content="article"><meta property="og:title" content="cppprimer第七章"><meta property="og:url" content="https://aldol-reaction.github.io/posts/76c57c5e/index.html"><meta property="og:site_name" content="aldol_reaction"><meta property="og:description" content="第7章 类"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-07-24T12:17:51.000Z"><meta property="article:modified_time" content="2022-08-07T13:59:01.944Z"><meta property="article:author" content="aldol_reaction"><meta property="article:tag" content="c++ primer"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://aldol-reaction.github.io/posts/76c57c5e/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://aldol-reaction.github.io/posts/76c57c5e/","path":"posts/76c57c5e/","title":"cppprimer第七章"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>cppprimer第七章 | aldol_reaction</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-K48RCS59KP"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-K48RCS59KP","only_pageview":false}</script><script src="/js/third-party/analytics/google-analytics.js"></script><script src="/js/third-party/analytics/baidu-analytics.js"></script><script async src="https://hm.baidu.com/hm.js?70a587710ee6d5e2204e4c01e7b0468c"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">aldol_reaction</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="aldol_reaction" src="/images/blogpic.png"><p class="site-author-name" itemprop="name">aldol_reaction</p><div class="site-description" itemprop="description">while(!Success()) Try();</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友链</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://nexuslbh.top/" title="http:&#x2F;&#x2F;nexuslbh.top&#x2F;" rel="noopener" target="_blank">Bohan Liu</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://aldol-reaction.github.io/posts/76c57c5e/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/blogpic.png"><meta itemprop="name" content="aldol_reaction"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="aldol_reaction"><meta itemprop="description" content="while(!Success()) Try();"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="cppprimer第七章 | aldol_reaction"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">cppprimer第七章</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-07-24 20:17:51" itemprop="dateCreated datePublished" datetime="2022-07-24T20:17:51+08:00">2022-07-24</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-08-07 21:59:01" itemprop="dateModified" datetime="2022-08-07T21:59:01+08:00">2022-08-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a> </span></span><span class="post-meta-item"><a href="/tags/c-primer/" rel="tag"><i class="fa fa-tag"></i> c++ primer</a> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p><strong>第7章 类</strong></p><span id="more"></span><p><strong>7.1 定义抽象数据类型</strong></p><p><strong>7.1.2 定义改进的sales_data类</strong></p><p><strong>引入 this</strong></p><p>成员函数通过一个名为 this 的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用 <code>total.isbn ()</code></p><p>则编译器负责把 total 的地址传递给 isbn 的隐式形参 this，等价于: <code>Sales_data::isbn(&amp;total)</code></p><p>在成员函数内部，可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为 this 所指的正是这个对象。任何对类成员的直接访问都被看作 this 的隐式引用：当 isbn 使用 bookNo 时，它隐式地使用 this 指向的成员，就像我们书写了 <code>this-&gt;bookNo</code>一样。</p><p>this 形参是隐式定义的。任何自定义名为 this 的参数或变量的行为都是非法的。我们可以在成员函数体内部使用 this，尽管没有必要: <code>std::string isbn () const {return this-&gt;bookNo;}</code></p><p>因为 this 的目的总是指向这个对象，所以 this 是一个常量指针，不允许改变 this 中保存的地址。</p><p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数，const 在参数列表后，this 此时指向常量指针，常量成员函数不能改变调用它的对象的内容：<code>string isbn() const {return bookNo;}</code></p><p>成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p><p>定义在类内部的函数是隐式的 inline 函数。</p><p>定义在类外部的函数要加上类作用域。</p><p><strong>定义一个返回 this 对象的函数</strong></p><p>函数combine的设计初衷类似于复合赋值运算符+=：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span> <span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class="line">	units_sold += rhs.units_sold; <span class="comment">// 把rhs的成员加到this对象的成员上</span></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回调用该函数的对象</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，为了与它保持一致，combine函数必须返回引用类型。</p><p><strong>7.1.3 定义类相关的非成员函数</strong></p><p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span> <span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span> </span>{ <span class="comment">// IO类属于不能被拷贝的类型，只能通过引用传递</span></span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.<span class="built_in">units_sold</span>() &lt;&lt; <span class="string">""</span></span><br><span class="line">	   &lt;&lt; item.<span class="built_in">revenue</span>() &lt;&lt;<span class="string">" "</span> &lt;&lt; item.avg _price();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>7.1.4 构造函数</strong></p><p>构造函数用来初始化类对象的数据成员。当类的对象被创建时，就会执行构造函数。</p><p>构造函数没有返回类型。</p><p>构造函数可以重载。</p><p>构造函数不可以声明为 const。当创建一个 const 对象时，直到构造函数完成其初始化过程，对象才真的取得其常量属性。</p><p>如果类没有任何构造函数，则编译器自己会创建默认构造函数：</p><ul><li>如果存在类内的初始值，用它来初始化成员。</li><li>否则，默认初始化该成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> {</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s) : <span class="built_in">bookNo</span>(s) {}</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(n * p) {}</span><br><span class="line">    <span class="built_in">Sales_data</span>(istream &amp;is) {<span class="built_in">read</span>(is, *<span class="keyword">this</span>);}</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> bookNo;};</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data &amp;<span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span> </span>{</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span> </span>{</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span> &lt;&lt; item.revenue;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>= default 的含义</strong></p><p>默认构造函数，这里没有参数的原因是类内有初始值。如果没有，需要用构造函数初始值列表。</p><p><strong>构造函数初始值列表</strong></p><p>冒号和冒号和花括号之间的代码。</p><p><strong>在类的外部定义构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(istream &amp;is) {</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>); <span class="comment">// read函数的作用是从is中读取一条交易信息然后存入this对象中</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>7.1.5 拷贝、赋值和折构</strong></p><p>对于拷贝、赋值和销毁对象等操作，类都通过相应的成员函数实现其功能，如果不主动定义这些操作，编译器就合成默认的版本。</p><p>对于某些类来说，无法使用默认合成的版本，比如管理动态内存的类就不能。</p><p><strong>7.2 访问控制与封装</strong></p><p>访问说明符：class, public。可以在类内出现多次。</p><p>class 和 struct 的<strong>唯一一点区别</strong>就是默认访问权限不同。</p><p><strong>当希望类的所有成员是 public 时，用 struct。</strong></p><p><strong>7.2.1 友元</strong></p><p>类可以允许其他类或函数访问它的非公有成员，方法就是令其他函数或类成为它的<strong>友元</strong>，加一条关键字 friend 开头的函数声明语句即可。</p><p><strong>友元声明只能出现在类的内部</strong>，最好在类的开始或结束位置集中声明友元。</p><p><strong>7.3 类的其他特性</strong></p><p><strong>7.3.1 类成员再探</strong></p><p><strong>定义类型成员</strong></p><p>类可以自定义某种类型在类内的别名。类型成员一样有访问限制。</p><p><strong>类型成员必须先定义后使用</strong>，因此类型成员应该出现在类开始的地方。</p><p><strong>默认构造函数</strong></p><p>当定义了构造函数，不会再有默认构造函数，如果需要必须显式声明：<code>Student() = default;</code></p><p><strong>类内初始值</strong></p><p>成员变量可以在类内定义的时候直接初始化。</p><p>此时构造函数的初始化列表可以不包含该成员变量，隐式使用其类内初始值。</p><p>类内初始值必须使用等号或花括号初始化。</p><p><strong>内联成员函数</strong></p><p><strong>4</strong>种方式使成员成为内联函数：</p><ol type="1"><li>在类内定义函数，为隐式内联。</li><li>在类内用关键字 inline 显式声明成员函数。</li><li>在类外用关键字 inline 定义成员函数。</li><li>同时在类内类外用 inline 修饰。</li></ol><p>inline 成员函数应该与类定义在同一个头文件中。</p><p><strong>可变数据成员</strong></p><p>const 成员函数不能修改成员变量。</p><p>但是用 <strong>mutable</strong> 将成员修饰为可变数据成员，就可以修改了。</p><p><strong>7.3.2 返回 *this 的成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> screen &amp;<span class="title">Screen::move</span><span class="params">(pos r, pos c)</span> </span>{</span><br><span class="line">    pos row = r * width; <span class="comment">// 计算行的位置</span></span><br><span class="line">    cursor = row + C; <span class="comment">// 在行内将光标移动到指定的列</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 以左值的形式返回对象</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> screen &amp;<span class="title">screen::set</span><span class="params">(<span class="type">char</span> c)</span> </span>{</span><br><span class="line">    contents [cursor] = C; <span class="comment">// 设置当前光标所在位置的新值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;          <span class="comment">// 将this对象作为左值返回</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myscreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span> (<span class="string">'#’); // 把光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br></pre></td></tr></table></figure><p>可以<strong>定义</strong>返回类型为类对象的引用的函数。如果定义的返回类型不是引用，返回的是 *this 的副本。</p><p>const 函数如果以引用的形式返回 this，返回类型就是一个常量引用。</p><p><strong>7.3.3 类类型</strong></p><p>类名不同，类不同。</p><p>一个类的成员类型不能是它自己，但是一旦一个类的名字出现后，它就被认为是被声明过了，所以类允许包含指向它自身类型的引用或指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span> {</span><br><span class="line">	screen window;</span><br><span class="line">	Link_screen *next;</span><br><span class="line">	Link_screen *prev;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>练习：定义一对类 X 和 Y，其中 X 包含一个指向 Y 的指针，而Y 包含一个类型为 X 的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>{</span><br><span class="line">	Y* y = <span class="literal">nullptr</span>;	</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>{</span><br><span class="line">	X x;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><strong>7.3.4 友元再探</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">screen</span> {</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;                    <span class="comment">// 其他类作为友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(screenIndex)</span></span>; <span class="comment">// 其他类的成员函数作为友元</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系，顺序：</p><ul><li>定义Window mgr类，其中声明clear函数，但是不能定义它。</li><li>在clear使用Screen 的成员之前必须先声明Screen。</li><li>定义Screen，包括对于clear的友元声明。</li><li>最后定义clear，此时它才可以使用screen的成员。</li></ul><p>如果一个类指定了友元类。则友元类的成员函数可以访问此类的所有成员。</p><p>友元关系不具有传递性。</p><p>重载函数名字相同，但是是不同的函数。如果想把一组重载函数声明为类的友元，需要对每一个分别声明。</p><p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。<br>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> {</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{<span class="comment">/*友元函数可以定义在类的内部*/</span>}</span><br><span class="line">    <span class="built_in">X</span>() {<span class="built_in">f</span>();} <span class="comment">//错误:f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span> </span>{<span class="keyword">return</span> <span class="built_in">f</span>();}<span class="comment">//错误:f还没有被声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//声明那个定义在X中的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>{<span class="keyword">return</span> <span class="built_in">f</span>();}<span class="comment">//正确:现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure><p>友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p><p><strong>7.4 类的作用域</strong></p><p>类名表示了作用域，一个函数只需要在函数名前授权一次作用域，其他变量就知道这是在类中，无需重复授权。</p><p>当类的成员函数的返回类型也是类的成员时，在定义它时要指明类 <code>Student::age Student::Getage() {}</code></p><p><strong>7.4.1 名字查找与类的作用域</strong></p><p><strong>普通程序名字查找的过程</strong></p><ol type="1"><li>首先在名字所在的块中寻找声明语句</li><li>如果没找到，继续查找外层作用域</li><li>如果最终还是没找到，报错</li></ol><p><strong>类的定义过程</strong></p><ol type="1"><li>编译成员的声明。</li><li>直到全部类可见后才编译成员函数体。</li></ol><p>在类内定义的类型名要放在类的开始，放在后面其他成员是看不见的。</p><p>类型名如果在类外已经定义过，不能在类内重定义。</p><p><strong>7.5 构造函数再探</strong></p><p><strong>7.5.1 构造函数初始值列表</strong></p><p>使用初始值列表对类的成员初始化才是真正的初始化，在构造函数的函数体内赋值并不是初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(<span class="type">const</span> string &amp;s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price) {</span><br><span class="line">    bookNo = s;</span><br><span class="line">    units_sold = cnt;</span><br><span class="line">    revenue = cnt * price;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>建议构造函数使用初始值。</p><p>如果成员是 <strong>const 或者是引用的话，必须初始化</strong>。赋值是错误的。</p><p>如果成员是类并且该类没有定义构造函数的话，必须初始化。</p><p>使用初始值列表初始成员时，成员初始化的顺序是按照类定义出现的顺序初始化的。</p><p><strong>默认实参和构造函数</strong></p><p>如果一个构造函数为所有参数提供了默认实参，则<strong>它实际上相当于定义了默认构造函数</strong>。</p><p>如果接受string 的构造函数和接受 istream&amp; 的构造函数都使用默认实参，调用默认实参函数时不知道应该重载哪一个函数，非法。</p><p><strong>7.5.2 委托构造函数</strong></p><p><strong>委托构造函数</strong>通过其他构造函数来执行自己的初始化过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price): <span class="built_in">bookNo</span>(s) , <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt * price) {}</span><br><span class="line"><span class="comment">//其余构造函数全都委托给另一个构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>) {}</span><br><span class="line">    <span class="built_in">Sales_data</span>(std: : string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) {}</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) : <span class="built_in">Sales_data</span>() {<span class="built_in">read</span>(is, *<span class="keyword">this</span>);}</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><strong>7.5.4 隐式的类类型转换</strong></p><p>如果构造函数只接受一个实参，则称作<strong>转换构造函数</strong>，它实际上定义了转换为此类类型的隐式转换机制。</p><p><strong>一个实参的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</strong></p><p><strong>只允许一步类型转换</strong></p><p>在进行隐式转换时，编译器只会自动地执行一步类型转换。</p><p>​ string null_book = "9-999"; item.combine(null_book); //conbine 函数接受 Sales_data 类类型，但该类定义了一个接受 string 参数的转换构造函数，所以这里会执行从 string 到该类类型的隐式转换，是正确的。 item.combine("9-999"); //隐式地使用了两种转换规则，所以是错误的。 item.combine(string("9-999")); //先显示地转换为 string，再隐式地转换为 Sales_data 类类型。是正确的。</p><p><strong>explicit-抑制构造函数定义的隐式转换</strong></p><p>将转换构造函数声明为 explicit 会阻止隐式转换。</p><p>关键字 explicit 只对一个实参的构造函数有效。因为需要多个实参的构造函数本来就不执行隐式转换。</p><p>explicit 只在类内声明构造函数时使用，在类外定义时不加。类似 static 成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span> (null_book);<span class="comment">//错误:string构造函数是explicit的</span></span><br><span class="line">item. <span class="built_in">combine</span> (cin);<span class="comment">//错误: istream构造函数是explicit的</span></span><br></pre></td></tr></table></figure><p><strong>explicit 构造函数只能用于直接初始化</strong></p><p>explicit 构造函数只能用于直接初始化，不能用于使用 "=" 的拷贝初始化。理解：因为 “=” 实际上是采用了拷贝赋值运算符，在传参时会进行隐式转换。</p><p>理解：不加 explicit 的转换构造函数，可以在赋值、传参、从函数返回等场合执行隐式转换，加了 explicit 后，就不能隐式转换了，也就是加了 explicit 的转换构造函数的意义就只是定义了一个新的构造函数，不具有提供隐式转换机制的额外功能了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;  <span class="comment">//正确</span></span><br><span class="line">Sales_data item2 = null_book; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>为转换显式地使用构造函数</strong></p><p>explicit 只是阻止了构造函数进行隐式转换，但是在传递实参时可以显式转换。</p><p>可以使用 explicit 的构造函数显式地强制进行转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));  <span class="comment">//正确</span></span><br><span class="line">iter.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(null_book));  <span class="comment">//正确，static_cast 可以使用 explicit 的构造函数</span></span><br></pre></td></tr></table></figure><p><strong>7.5.5 聚合类</strong></p><p>满足以下四个条件的类是聚合类：</p><ol type="1"><li>所有成员都是public的</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类和 virtual 函数</li></ol><p>聚合类可以像结构体一样用花括号初始值列表初始化。如果花括号内元素数量少于类成员数量，靠后的成员将被值初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu = {<span class="string">"Li Ming"</span>, <span class="number">18</span>};</span><br></pre></td></tr></table></figure><p><strong>7.5.6 字面值常量类</strong></p><p><strong>constexpr 函数</strong>的参数和返回值都必须是字面值类型。</p><p>算术类型、引用和指针都是字面值类型，此外<strong>字面值常量类</strong>也是字面值类型。</p><p>字面值类型属于常量表达式，constexpr 就是用来声明常量表达式的。</p><p>聚合类属于字面值常量类。</p><p>如果不是聚合类，满足以下四个条件的类也是字面值常量类：</p><ol type="1"><li>数据成员都是字面值类型。</li><li><strong>类至少含有一个 constexpr 构造函数</strong></li><li>如果一个数据成员有类内初始值，则初始值必须是常量表达式（如果成员是类，则初始值必须使用成员自己的 constexpr 构造函数）</li><li>类必须使用析构函数的默认定义。</li></ol><p><strong>constexpr 构造函数</strong></p><p>类的构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数。</p><p>constexpr 构造函数可以声明成 =default 或 =delete。</p><p>constexpr 构造函数的函数体应该是空的（原因：constexpr 函数的函数体只能包含一条返回语句，而构造函数不能包含返回语句）</p><p>constexpr 构造函数必须初始化所有数据成员。初始值必须是常量表达式或使用其自己的 constexpr 构造函数。</p><p>使用前置关键字 constexpr 来声明 constexpr 构造函数</p><p>​ class Debug{ public: constexpr Debug(bool b=true):a(b){}; private: bool a; };//定义一个类记得加分号 constexpr Debug prod(false);//定义一个 Debug 类型的对象。实参应为常量表达式。</p><p><strong>7.6 类的静态成员</strong></p><p><strong>类的静态成员与类本身直接关联</strong>，而不是与类的对象保持关联。</p><p>静态成员可以是 public 或 private 的。</p><p>静态成员不与任何对象绑定在一起。</p><p>静态成员函数不包含 this 指针，不能声明为 const 的，不能在 static 函数体内使用 this 指针。</p><p>理解：因为 static 函数不能使用 this 指针，所以它是无法使用类的非 static 数据成员的。</p><p><strong>定义静态成员</strong></p><p>可以在类内或类外定义静态成员。当在类外定义时，<strong>不能重复 static 关键字</strong>，static 只出现在类内的声明中。</p><p>只有 constexpr 类型的静态数据成员可以在类内初始化，但是也需要在类外定义。</p><p>其他的静态数据成员<strong>都在类内声明，类外定义并初始化</strong>。</p><p><strong>静态成员可以用的特殊场景</strong></p><p>静态数据成员可以是<strong>不完全类型</strong>，比如静态数据成员的类型可以是它所属的类类型本身。</p><p>静态成员可以作为默认实参。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/posts/aa2834e7/" rel="prev" title="c++ primer 第二章"><i class="fa fa-chevron-left"></i> c++ primer 第二章</a></div><div class="post-nav-item"><a href="/posts/81ae541d/" rel="next" title="cppprimer第八章">cppprimer第八章 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC81NjgzNC8zMzI5OA"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">aldol_reaction</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">70k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:04</span></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv">本站访客数 <span id="busuanzi_value_site_uv"></span> 人 | <span id="busuanzi_container_site_pv">本站访问量 <span id="busuanzi_value_site_pv"></span> 次</span><div class="run_time" style="text-align:center"><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("07/10/2022 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div></span></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script><script src="/js/third-party/comments/livere.js"></script></body></html>