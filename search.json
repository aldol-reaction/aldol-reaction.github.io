[{"title":"6.828lab1","url":"/posts/2a4183f5/","content":"<span id=\"more\"></span>\r\n<h2 id=\"准备内核\">准备内核</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https://pdos.csail.mit.edu/6.828/2017/jos.git</span><br><span class=\"line\">sudo make \t\t\t# 编译</span><br><span class=\"line\">sudo make qemu-nox-gdb</span><br><span class=\"line\">sudo make gdb    \t# 打开一个新终端</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"make命令详解\">make命令详解</h3>\r\n<h4 id=\"make\">make</h4>\r\n<p>等价于 make all.</p>\r\n<p>它是一个解释makefile中指令的命令工具</p>\r\n<p>执行make时，默认会去(当前文件夹下),找名为Makefile的文件</p>\r\n<p>根据Makefile文件来编译源代码，生成目标文件及可执行文件</p>\r\n<p>在每次使用make时,都会重新生成objects，新产生的object会覆盖旧的objects</p>\r\n<h3 id=\"make-clean\">make clean</h3>\r\n<p>清除以前的make命令编译后所产生的object文件(即后缀为“.o”的文件)及其生成的可执行文件</p>\r\n<p>一般来说，在每次使用make时,都会重新生成objects，新产生的object会覆盖旧的objects</p>\r\n<p>但是实际用时，经过多次编译后，必须使用make\r\nclean（直接make，以前留下来的错误不能清除干净）</p>\r\n<h3 id=\"make-install\">make install</h3>\r\n<p>将编译成功的可执行文件移动到make编译时填写的目录，依据生成的makefile文件</p>\r\n<p>一般默认系统目录/usr/local/bin</p>\r\n<h3 id=\"make-distclean\">make distclean</h3>\r\n<p>类似于make clean</p>\r\n<p>清除以前的make命令编译后所产生的object文件(即后缀为“.o”的文件)及其生成的可执行文件，并将configure生成的文件全部删除掉</p>\r\n<p>通常在使用make clean后使用，清理的更干净，避免影响再次编译</p>\r\n<h2 id=\"rom-bios启动过程\">ROM BIOS启动过程</h2>\r\n<p><a href=\"https://pdos.csail.mit.edu/6.828/2017/labguide.html#gdb\">gdb简介</a></p>\r\n<p>PC的物理结构</p>\r\n<p><img src=\"C:\\Users\\HuaWei\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220902091958099.png\" alt=\"image-20220902091958099\"></p>\r\n<p>该地址空间是物理空间,全部都是通过电路硬编码组成的。</p>\r\n<p>本实验仿真的是80386处理器,该处理器32位,寻址空间2^32=4G。第一代 PC\r\n基于16位 Intel 8088处理器，只能寻址1 MB 的物理内存。因此，早期 PC\r\n的物理地址空间将以0x00000000开始，但以0x000FFFFF 而不是0xFFFFFFFF\r\n结束。</p>\r\n<p>Low Memory：早期个人电脑可以使用的唯一随机存取存储器(RAM，Random\r\nAccess\r\nMemory，随机存取存储器，也称主存)，为了兼容早期计算机而保存下来。00000H~003FFH:\r\n1KB 中断向量区。</p>\r\n<p>从0x000A0000到0x000FFFF 的384kB 区域是 ROM(Read-Only\r\nMemory，只读存储器) 部分，为特殊用途的硬件留下来的物理地址空间。</p>\r\n<ul>\r\n<li>VGA\r\nDisplay：显存，向其写入数据，便可以被显示卡显示到显示屏上。外设。</li>\r\n<li>expansion Roms：ROM 扩展。外设。</li>\r\n<li>BIOS：基本输入/输出系统(Basic Input/Output\r\nSystem)，占用从0x000F0000到0x000FFFFF 的64KB 区域。CPU\r\n用于获取操作系统的一段程序，位于集成在PC内部的一个EPROM芯片(flash)中负责执行基本的系统初始化。\r\n<ul>\r\n<li>建立中断描述符表(Interrupt Descriptor Table，IDT)。</li>\r\n<li>初始化各种设备，比如VGA PCI bus。</li>\r\n<li>寻找可启动的设备。</li>\r\n<li>BIOS结束,进入磁盘(disk)中的内核引导器(boot loader)。</li>\r\n</ul></li>\r\n</ul>\r\n<p>Extended Memory：另一部分的 RAM。</p>\r\n<p>memory mapped devices：32位PCI设备(Program Control\r\nInterrupt，接收外部中断的设备，并行同步的总线)</p>\r\n<p>由于<code>JOS</code>设计的限制,\r\n在之后所有关于<code>JOS</code>的<code>lab</code>中只使用前256M的物理内存。</p>\r\n<h2 id=\"rom-bios\">ROM BIOS</h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">The target architecture is assumed to be i8086</span><br><span class=\"line\">[f000:fff0]    0xffff0: ljmp   <span class=\"variable\">$0xf000</span>,<span class=\"variable\">$0xe05b</span> <span class=\"comment\"># FFFF0H~FFFFFH 启动区</span></span><br><span class=\"line\">0x0000fff0 <span class=\"keyword\">in</span> ?? ()</span><br><span class=\"line\">+ symbol-file obj/kern/kernel</span><br><span class=\"line\">(gdb)</span><br></pre></td></tr></table></figure>\r\n<p>[CS:IP]：[代码段:指令指针]</p>\r\n<p>实模式(Real\r\nMode，程序中用到的地址都是真实的物理地址)下地址的计算方式：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">地址 = 16 * CS + IP</span><br><span class=\"line\">16 * 0xf000 + 0xfff0 # 十六进制</span><br><span class=\"line\">= 0xf0000 + 0xfff0</span><br><span class=\"line\">= 0xffff0</span><br></pre></td></tr></table></figure>\r\n<p>该指令在BIOS区域的最后---倒数第16个字节，16字节做不了什么，于是跳到开头。</p>\r\n<p>gdb 利用 <code>si</code>(Step Instruction) 进行单步追踪。</p>\r\n<p>ljmp，跳到 CS=f000, IP=e05b 的地址。</p>\r\n<h2 id=\"the-boot-loader\">The Boot Loader</h2>\r\n<p>软盘(Floppy)，硬盘都可以被划分为一个个大小为512字节的区域(Magnetic\r\nDisk)，叫做扇区(sector)。一个扇区是一次磁盘操作的最小单位。</p>\r\n<p>如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区。</p>\r\n<p>当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址0x7c00~0x7dff这个区域内。使用\r\nljmp 指令跳到 [0000,7c00] 后，控制权从 BIOS 交给了 Boot\r\nLoader，早期为一个扇区大小。</p>\r\n<p>整个boot\r\nloader是由一个汇编文件，boot/boot.S，以及一个C语言文件，boot/main.c组成，其功能是：</p>\r\n<ul>\r\n<li>把 CPU 从实模式转换为32bit的保护模式，原来的地址空间只能够得到1MB(20\r\nbits),现在可以到4GB(32 bits)。此时段偏移量从 16位变成了32位。</li>\r\n<li>通过使用x86特定的IO指令，直接访问IDE磁盘设备寄存器，从磁盘中读取内核。</li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n"},{"title":"c++ primer 第二章","url":"/posts/aa2834e7/","content":"<p><strong>第2章 变量和基本类型</strong></p>\r\n<span id=\"more\"></span>\r\n<p><strong>2.1 基本内置类型</strong></p>\r\n<p><strong>2.1.1 算术类型</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>含义</th>\r\n<th>最小尺寸</th>\r\n<th>备注</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>char</td>\r\n<td>字符</td>\r\n<td>8位</td>\r\n<td>1B(8b)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>wchar_t</td>\r\n<td>宽字符</td>\r\n<td>16位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>char16_t</td>\r\n<td>Unicode字符</td>\r\n<td>16位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>char32_t</td>\r\n<td>Unicode字符</td>\r\n<td>32位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>float</td>\r\n<td>单精度浮点数</td>\r\n<td>6位有效数字</td>\r\n<td>1个字(32b)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>double</td>\r\n<td>双精度浮点数</td>\r\n<td>10位有效数字</td>\r\n<td>2个字(64b)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>long double</td>\r\n<td>扩展精度浮点数</td>\r\n<td>10位有效数字</td>\r\n<td>4个字(128b)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>存储的基本单元：字，32b/64b。</p>\r\n<p>明确知晓数值不可能为负时，选用无符号类型。</p>\r\n<p>char 是否有符号并不确定，因此使用 signed char 或 unsigned char\r\n来指定是否有符号。</p>\r\n<p>整数运算用 int/long long。</p>\r\n<p>浮点数运算用 double。float 和 double 的计算代价相差无几。</p>\r\n<p><strong>2.1.2 类型转换</strong></p>\r\n<p>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>\r\n<p>赋给带符号类型超出范围的值时，结果是未定义的。</p>\r\n<p>带符号数与无符号数做运算，会被转化为无符号数。</p>\r\n<p><strong>2.1.3 字面值常量</strong></p>\r\n<p><strong>整型和浮点型字面值</strong></p>\r\n<p>0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p>\r\n<p>十进制字面值的类型是 int, long, long long\r\n中可以放下它的最小尺寸。</p>\r\n<p>八进制和十六进制字面值的类型是 int, long, long long, unsigned int,\r\nunsigned long, unsigned long long 中可以放下它的最小尺寸。</p>\r\n<p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或\r\ne 标识，默认 double：3.14, 0., 0e0, .001, 3.14E2。</p>\r\n<p><strong>字符和字符串字面值</strong></p>\r\n<p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0\r\n个或多个字符则构成字符串型字面值。</p>\r\n<p>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（'\\0'），因此字符串字面值的实际长度要比它的内容多\r\n1。</p>\r\n<p>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"A \"</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"B\"</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\r\n<p><strong>转义序列</strong></p>\r\n<p>换行符：，横向制表符：，报警符：，纵向制表符：退格符：<strong>双引号：\"，</strong></p>\r\n<p><strong>反斜线：\\，单引号：'</strong>，<strong>问号：?</strong>，回车符：进纸符：述转义序列被当作一个字符使用。</p>\r\n<p>也可以使用泛化的转移序列，形式是  后跟 1~3 个八进制数字或 后跟 1\r\n个或多个十六进制数字。</p>\r\n<p>如果  后面跟着的八进制数字超过 3 个，只有前三个数字与\r\n 构成转义序列。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\<span class=\"number\">115</span>  <span class=\"comment\">//字符 M</span></span><br><span class=\"line\">\\x4d  <span class=\"comment\">//字符 M</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>指定字面值的类型</strong></p>\r\n<p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。</p>\r\n<p>字符和字符串字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>前缀</th>\r\n<th>含义</th>\r\n<th>类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>u</td>\r\n<td>Unicode 16字符</td>\r\n<td>char16_t</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>U</td>\r\n<td>Unicode 32字符</td>\r\n<td>char32_t</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>L</td>\r\n<td>宽字符</td>\r\n<td>wchar_t</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>u8</td>\r\n<td>UTF-8(仅用于字符串字面常量)</td>\r\n<td>char</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>整形字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>后缀</th>\r\n<th style=\"text-align: left;\">最小匹配类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>u or U</td>\r\n<td style=\"text-align: left;\">unsigned</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>l or L</td>\r\n<td style=\"text-align: left;\">long</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>ll or LL</td>\r\n<td style=\"text-align: left;\">long long</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>浮点型字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>后缀</th>\r\n<th>类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>f or F</td>\r\n<td>double</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>l or L</td>\r\n<td>long double</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f。</p>\r\n<p>用 LL 代替 ll 防止与 1 混淆。</p>\r\n<p><strong>2.2 变量</strong></p>\r\n<p><strong>2.2.1 变量定义</strong></p>\r\n<p><strong>初始化</strong></p>\r\n<p>可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> price = <span class=\"number\">109.99</span>, discount = price * <span class=\"number\">0.6</span>;</span><br></pre></td></tr></table></figure>\r\n<p>初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值<strong>擦除</strong>并用一个新值来替代。</p>\r\n<p><strong>列表初始化</strong></p>\r\n<p>四种初始化方式，其中使用花括号的方式叫做列表初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = {<span class=\"number\">0</span>};</span><br><span class=\"line\"><span class=\"type\">int</span> i{<span class=\"number\">0</span>};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">double</span> ld = <span class=\"number\">3.14</span>; <span class=\"type\">int</span> a{ld}, b = {ld}; <span class=\"comment\">//错误，存在信息丢失的风险，转换未执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld;  <span class=\"comment\">//正确</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>默认初始化</strong></p>\r\n<p>定义于任何函数之外的内置类型则被初始化为 0；</p>\r\n<p>定义于函数体内的内置类型的对象如果没有初始化，则其值<strong>未定义</strong>。</p>\r\n<p>类的对象如果没有显式地初始化，则其由类确定。</p>\r\n<p><strong>2.2.2 变量声明和定义的关系</strong></p>\r\n<p>声明：使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。规定了变量的类型和名字。</p>\r\n<p>定义：在声明的基础上，创建与名字关联的实体，即申请存储空间，还可能会为变量赋一个初始值。</p>\r\n<p>要声明一个变量加\r\nextern，声明变量不能赋值，任何包含了显式初始化的声明即成为定义。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> i;     <span class=\"comment\">// 声明 i</span></span><br><span class=\"line\"><span class=\"type\">int</span> i;            <span class=\"comment\">// 定义 i；</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>\r\n<p>变量只能被定义一次，但是可以多次声明。</p>\r\n<p>extern 定义的变量必须是全局的，这样才可能在其他文件中使用。</p>\r\n<p>如果要在多个文件中使用同一个变量，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>\r\n<p>C++ 是静态类型语言，在编译阶段检查类型。</p>\r\n<p><strong>2.2.3 标识符</strong></p>\r\n<p>标识符组成：字母、数字、下划线。不能以数字开头。标识符的长度没有限制。</p>\r\n<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。</p>\r\n<p>变量命名规范：</p>\r\n<ol type=\"1\">\r\n<li>变量名一般用小写字母。</li>\r\n<li>用户自定义的类型一般以大写字母开头。</li>\r\n<li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li>\r\n<li>当你第一次使用变量再定义它。</li>\r\n</ol>\r\n<p><strong>2.2.4 名字的作用域</strong></p>\r\n<p>花括号以内是作用域。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> {</span><br><span class=\"line\">\t<span class=\"type\">int</span> ival = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">} <span class=\"keyword\">while</span>(ival); <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.3 复合类型</strong></p>\r\n<p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种。</p>\r\n<p>声明语句 = 基本数据类型 + 声明符(类型修饰符(&amp;/*) +\r\n标识符(变量名))</p>\r\n<p><strong>2.3.1 引用</strong></p>\r\n<p>引用是给<strong>对象</strong>起的别名，不能与字面值或表达式绑定。</p>\r\n<p>初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。故引用必须初始化。</p>\r\n<p>对引用的所有操作都是对与之绑定的对象的操作。</p>\r\n<p>引用非对象。不能定义对引用的引用，因为引用非对象。</p>\r\n<p>引用只能绑定同类型对象。</p>\r\n<p><strong>2.3.2 指针</strong></p>\r\n<p>指针存放某个<strong>对象</strong>的地址。</p>\r\n<p>指针必须指向同类型对象。</p>\r\n<p><strong>指针与引用的不同：</strong></p>\r\n<ol type=\"1\">\r\n<li>指针可以不初始化，引用不可以。</li>\r\n<li>指针是一个对象，引用不是。</li>\r\n<li>指针可以重定向，引用不可以。</li>\r\n</ol>\r\n<p>从右向左读比较易于弄清：</p>\r\n<ul>\r\n<li>离变量名最近的符号(&amp;)对变量的类型有最直接的影响，因此 r\r\n是一个引用。</li>\r\n<li>声明符的其余部分用以确定 r 引用的类型是什么，*说明 r\r\n引用的是一个指针。</li>\r\n<li>声明的基本数据类型部分指出 r 引用的是一个int指针。</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"type\">int</span> *&amp;r = p;</span><br></pre></td></tr></table></figure>\r\n<p><strong>空指针</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 三种定义空指针的方式。最好用第一种</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"literal\">NULL</span>;    <span class=\"comment\">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>\r\n<p>初始化指针，如果不清楚该指向谁，先初始化为 nullptr。</p>\r\n<p><strong>void* 指针</strong></p>\r\n<p>void*\r\n指针是特殊的指针类型，可以存放任意对象的地址。它的用处比较有限，不能直接操作它所指的对象。</p>\r\n<p><strong>2.4 const限定符</strong></p>\r\n<p><strong>const\r\n对象必须初始化</strong>，因为一旦创建就不能再改变值。</p>\r\n<p>默认情况下，const 对象仅在文件内有效。</p>\r\n<p>如果想在多个文件间共享 const 对象，必须在变量的声明和定义前都添加\r\n<strong>extern</strong> 关键字并在本文件中声明。</p>\r\n<p><strong>2.4.1 const的引用</strong></p>\r\n<p>const 引用不能改变引用的对象。</p>\r\n<p>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</p>\r\n<p>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;r1 = ci; <span class=\"comment\">// 错误，试图让一个非常量引用指向一个常量对象</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;r2 = i; <span class=\"comment\">// 正确，一个常量引用指向一个非常量对象</span></span><br></pre></td></tr></table></figure>\r\n<p>引用的类型必须与其所引用对象的类型一致，但是有一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>\r\n<p><strong>2.4.2 指针和const</strong></p>\r\n<p>指向常量的指针的用法和常量引用相似，<strong>但是是不一样的。</strong>它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其他途径改变值</p>\r\n<p><strong>2.4.3 顶层const</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>顶层 const</th>\r\n<th>底层 const</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>含义</td>\r\n<td>对象本身是个常量</td>\r\n<td>所指的对象是一个常量</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>适用范围</td>\r\n<td>任何数据类型通用</td>\r\n<td>引用和指针</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>初始化</td>\r\n<td>必须</td>\r\n<td>不必须</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>引用实际上只能是底层 const(常量引用)，不存在顶层 const\r\n的引用，因为引用非对象。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;<span class=\"type\">const</span> p2 = p1;<span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\r\n<p>对于指针和引用而言，顶层 const 在右边，底层 const\r\n在左边。对于其他类型，全都是顶层 const</p>\r\n<p>执行对象的拷贝操作时，顶层 const 没有影响，两个对象要有相同的底层\r\nconst 资格。不能将底层 const\r\n拷贝给非常量，反之可以，非常量将会转化为常量。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = ci; <span class=\"comment\">// 正确，顶层 const 无影响</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.4.4 constexpr和常量表达式</strong></p>\r\n<p>常量表达式是指<strong>值不会改变</strong>并且<strong>在编译过程就能得到计算结果</strong>的表达式。</p>\r\n<p><strong>字面值属于常量表达式</strong>，由常量表达式初始化的 const\r\n对象也是常量表达式。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">32</span>;          <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> b = a + <span class=\"number\">1</span>;       <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> sz = <span class=\"built_in\">get_size</span>(); <span class=\"comment\">// 不是常量表达式，因为虽然 sz 是常量，但它的具体值等到运行时才知道。</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>cosntexpr变量</strong></p>\r\n<p>由 constexpr 声明的变量必须用常量表达式初始化。</p>\r\n<p>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化\r\nconstexpr 变量。</p>\r\n<p>constexpr int sz = size(); //只有当 size() 是一个 constexpr\r\n函数时这才是一条正确的声明语句。</p>\r\n<p><strong>constexpr 变量是真正的“常量”</strong>，而 const\r\n现在一般只用来表示 <strong>“只读”</strong>。</p>\r\n<p><strong>字面值类型</strong></p>\r\n<p><strong>算术类型、引用、指针、字面值常数类、枚举属于字面值类型</strong>，自定义类、IO\r\n库，string类则不属于。</p>\r\n<p>cosntexpr 指针的初始值必须是 nullptr\r\n或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p>\r\n<p><strong>指针和constexpr</strong></p>\r\n<p>注意区分 constexpr 和 const 。constexpr 都是顶层\r\nconst，仅对指针本身有效。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p = <span class=\"literal\">nullptr</span>;     <span class=\"comment\">// p 是一个指向整型常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> *q = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.5 处理类型</strong></p>\r\n<p><strong>2.5.1 类型别名</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">double</span> wages; <span class=\"keyword\">using</span> wages = <span class=\"type\">double</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> wages base, *p; <span class=\"comment\">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>指针、常量和类型别名</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span>* pstring; </span><br><span class=\"line\"><span class=\"type\">const</span> pstring cstr = <span class=\"number\">0</span>; <span class=\"comment\">// 是一个指向 char 的常量指针。</span></span><br></pre></td></tr></table></figure>\r\n<p>不能采用直接替换的方式将其理解为 const char* cstr =\r\n0，这是错误的，是一个指向 const char 的指针。</p>\r\n<p>替换前基本数据类型是 char*。</p>\r\n<p>替换后基本数据类型是 const char，*是声明符的一部分。</p>\r\n<p><strong>2.5.2 auto类型说明符</strong></p>\r\n<p>auto\r\n可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型。</p>\r\n<p><strong>复合类型、常量和auto</strong></p>\r\n<p>编译器推断出的 auto\r\n类型有时和初始值并不一样，编译器会进行适当的调整：</p>\r\n<ol type=\"1\">\r\n<li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li>\r\n<li>auto 一般会忽略掉顶层 const，如果希望 auto 是一个顶层\r\nconst，需要明确指出。</li>\r\n<li>设置一个类型为 auto 的引用/指针时，顶层 const 保留。</li>\r\n<li>auto 会保留底层 const。</li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> e = &amp;ci;       <span class=\"comment\">// e是一个指向整数常量的指针(对常量对象取地址是一种底层const)</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span> f = ci;  <span class=\"comment\">// ci的推演类型是int，f是const int (明确指出auto是顶层const)</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;g = ci;       <span class=\"comment\">// g是一个整型常量引用，绑定到ci</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;h = <span class=\"number\">42</span>;       <span class=\"comment\">// 错误:不能为非常量引用绑定字面值</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;j = <span class=\"number\">42</span>; <span class=\"comment\">// 正确:可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>\r\n<p>int 与 int*、int&amp; 是一个基本数据类型，而 const int 与 int\r\n不是一种类型。</p>\r\n<p>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p>\r\n<p><strong>2.5.3 decltype类型指示符</strong></p>\r\n<p>当希望获得表达式的类型但是不要值的时候，可以使用类型说明符\r\ndecltype。</p>\r\n<p>如果 decltype\r\n使用的表达式是一个变量，则它返回该变量的类型（<strong>包括顶层 const\r\n和引用在内</strong>）。</p>\r\n<p>当获得的类型是引用时，必须初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">0</span>, &amp;cj = ci;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(ci) x = <span class=\"number\">0</span>;  <span class=\"comment\">// x 的类型是 const int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) y = x;  <span class=\"comment\">// y 的类型是 const int&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) z;      <span class=\"comment\">// z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>decltype 和引用</strong></p>\r\n<p>表达式的值类别为<strong>左值</strong>产生 T&amp;\r\n，<strong>右值</strong>产生 T。</p>\r\n<p>左值类型：<strong>解引用指针</strong>，<strong>给变量加括号，赋值操作</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">42</span>, &amp;r = i, *p;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(r+<span class=\"number\">0</span>) b;      <span class=\"comment\">// b 的类型是 int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(*p) c = i;   <span class=\"comment\">// c 的类型是 int&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>((i)) d = i;  <span class=\"comment\">// d 的类型是 int&amp;</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.6 自定义数据结构</strong></p>\r\n<p><strong>2.6.1 定义Sales_data类型</strong></p>\r\n<p>定义类时可以给数据成员提供<strong>类内初始值</strong>以进行初始化。没有类内初始值的成员则被默认初始化。</p>\r\n<p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>\r\n<p><strong>2.6.3 编写自己的头文件</strong></p>\r\n<p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p>\r\n<p>头文件通常定义那些<strong>只能被定义一次的实体</strong>，比如类、const、constexpr\r\n等。</p>\r\n<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>\r\n<p><strong>预处理器概述</strong></p>\r\n<p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p>\r\n<p>预处理变量有两种状态：已定义和未定义。预处理变量的名字全部大写。</p>\r\n<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>\r\n<p>c++ 中包含三个头文件保护符：</p>\r\n<ol type=\"1\">\r\n<li>#define：把一个名字设定为预处理变量</li>\r\n<li>#ifdef：当且仅当变量已定义时为真</li>\r\n<li>#ifndef：当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直到遇到\r\n#endif 为止</li>\r\n<li>#endif</li>\r\n</ol>\r\n<p>预处理变量无视作用域的规则，作用范围是文件内。</p>\r\n","categories":["c++"],"tags":["c++ primer"]},{"title":"cppprimer第九章","url":"/posts/fb637542/","content":"<p><strong>第九章 顺序容器</strong></p>\r\n<span id=\"more\"></span>\r\n<p><strong>9.1 顺序容器概述</strong></p>\r\n<p><strong>几种顺序容器</strong></p>\r\n<p><strong>vector：</strong>支持快速随机访问。在<strong>尾部</strong>插入/删除速度快。</p>\r\n<p><strong>deque：</strong>支持快速随机访问。在<strong>头尾</strong>插入/删除都很快。</p>\r\n<p><strong>list：</strong>双向链表<strong>。只支持</strong>双向顺序访问。在任何位置插入/删除都很快。</p>\r\n<p><strong>forward_list</strong>：单项链表。只支持单向顺序访问。在任何位置插入/删除都很快。</p>\r\n<p><strong>string</strong>：支持快速随机访问。在<strong>尾部</strong>插入/删除速度快。</p>\r\n<p><strong>array：</strong>固定大小数组。支持快速随机访问。</p>\r\n<p>可以发现：vector/deque/string/array 都是顺序存储结构。 list\r\n是链式存储结构。但是他们都是顺序容器。</p>\r\n<p>list 的额外内存开销相比其他大很多。</p>\r\n<p>array 是一种比内置数组更好的类型。</p>\r\n<p>farward_list 没有 size 操作。这种列表与最好的手写链表性能一样好。</p>\r\n<p><strong>容器选择</strong></p>\r\n<p><strong>vector/list/deque</strong> 三种容器的比较：</p>\r\n<ol type=\"1\">\r\n<li>如果没有特殊的理由，使用 vector 是最好的选择</li>\r\n<li>如果有很多小的元素，不用 list</li>\r\n<li>如果空间开销很重要，不用 list</li>\r\n<li>如果需要在中间位置插入/删除，用 list</li>\r\n<li>如果需要在头尾位置插入/删除，用 deque</li>\r\n<li>如果需要随机访问，用 vector 或 deque</li>\r\n<li>如果需要在中间位置插入，而后随机访问：</li>\r\n</ol>\r\n<ul>\r\n<li>如果可以通过排序解决，就先插到尾部，而后排序</li>\r\n<li>在输入阶段用 list ，输入完成后拷贝到 vector 中</li>\r\n</ul>\r\n<p><strong>9.2 容器库概览</strong></p>\r\n<p><strong>9.2.1 迭代器</strong></p>\r\n<p>迭代器之间比较只有 == 和 !=</p>\r\n<p>当不需要写访问时，应使用 <code>cbegin,cend</code></p>\r\n<p><strong>9.2.4 容器定义和初始化</strong></p>\r\n<p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。</p>\r\n<p>当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的。新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">list&lt;string&gt; authors = {<span class=\"string\">\"Milton\"</span>, <span class=\"string\">\"Shakespeare\"</span>, <span class=\"string\">\"Austen\"</span>};</span><br><span class=\"line\">vector&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt; articles = {<span class=\"string\">\"a\"</span>, <span class=\"string\">\"an\"</span>, <span class=\"string\">\"the\"</span>};</span><br><span class=\"line\"><span class=\"function\">list&lt;string&gt; <span class=\"title\">list2</span><span class=\"params\">(authors)</span> </span>; <span class=\"comment\">// 正确: 类型匹配</span></span><br><span class=\"line\"><span class=\"function\">deque&lt;string&gt; <span class=\"title\">authList</span><span class=\"params\">(authors)</span></span>; <span class=\"comment\">//错误:容器类型不匹配</span></span><br><span class=\"line\"><span class=\"function\">vector&lt;string&gt; <span class=\"title\">words</span><span class=\"params\">(articles)</span></span>; <span class=\"comment\">//错误:容器类型必须匹配</span></span><br><span class=\"line\"><span class=\"function\">forward_list&lt;string&gt; <span class=\"title\">words</span><span class=\"params\">(articles.begin(), articles.end())</span></span>;<span class=\"comment\">//正确:可以将const char元素转换为string</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>array初始化</strong></p>\r\n<p>定义一个<strong>array</strong>，既需要指定元素类型，也需要<strong>指定大小</strong>：<code>array&lt;int,42&gt;;</code></p>\r\n<p>array 列表初始化时，列表元素个数小于等于 array\r\n大小，剩余元素默认初始化为 0。</p>\r\n<p><strong>9.2.5 赋值和swap</strong></p>\r\n<p><strong>“=”赋值</strong></p>\r\n<p>要求左右容器类型一样。</p>\r\n<p>对容器使用赋值运算符（除 array\r\n外），将会使该容器的<strong>所有元素</strong>被替换。如果两个容器大小不等，<strong>赋值后都与右边容器的原大小相同</strong>。</p>\r\n<p>array要求赋值前大小一样。所以不支持 assign，花列表赋值。</p>\r\n<p><strong>assign</strong></p>\r\n<p><strong>assign</strong>\r\n是赋值操作，可以用于<strong>顺序容器</strong>。</p>\r\n<p>“=” 要求两边类型相同， assign 要求只要可以转换即可</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">list&lt;string&gt; names;</span><br><span class=\"line\">vector&lt;<span class=\"type\">const</span> <span class=\"type\">char</span>*&gt; oldstyle;</span><br><span class=\"line\">names.<span class=\"built_in\">assign</span>(oldstyle.<span class=\"built_in\">cbegin</span>(), oldstyle.<span class=\"built_in\">cend</span>()); <span class=\"comment\">//正确:可以将const char*转换为string</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>swap</strong></p>\r\n<p>对 array ，swap 交换两个 array\r\n中的元素值。指针、引用和迭代器绑定的元素不变（值变）。</p>\r\n<p>对于其他容器，swap 不交换元素，只交换数据结构，因此 <strong>swap\r\n操作非常快</strong>。</p>\r\n<p>对于 string，swap\r\n后，指针、引用和迭代器会失效。对于其他容器，交换后指针指向了另一个容器的相同位置。</p>\r\n<p>建议统一使用 swap(a,b)，而非 a.swap(b)</p>\r\n<p>对于 array，swap 操作的时间与元素数目成正比，对于其他容器，swap\r\n操作的时间是常数。</p>\r\n<p><strong>9.2.6 容器大小操作</strong></p>\r\n<p>max_size 返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p>\r\n<p><strong>9.3 顺序容器操作</strong></p>\r\n<p><strong>9.3.1 添加元素</strong></p>\r\n<p>注意向 vector、string 或 deque\r\n插入元素会使所有指向容器的迭代器、引用和指针失效。</p>\r\n<p>添加的都是元素的拷贝，不是元素本身。</p>\r\n<p>头尾添加返回\r\nvoid，<strong>中间添加返回指向新添加元素的迭代器</strong></p>\r\n<p><strong>push</strong></p>\r\n<p>vector 和 string 不支持 push_front 和 emplace_front；forward_list\r\n不支持 push_back 和 emplace_back。</p>\r\n<p>push 头尾是常数时间。</p>\r\n<p><strong>emplace</strong></p>\r\n<p>push 和 insert 传递的是元素类型的对象， emplace\r\n则将<strong>参数</strong>传递给元素类型的构造对象。</p>\r\n<p>即\r\nemplace参数即为元素类型构造函数的参数，因此可以为空（默认初始化）。</p>\r\n<p><strong>insert</strong></p>\r\n<p>insert 返回值是指向添加的元素中第一个元素的迭代器</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">insert</span>(p, t);       <span class=\"comment\">// 在迭代器 p 所指元素之前添加一个 t</span></span><br><span class=\"line\">c.<span class=\"built_in\">insert</span>(p, n, t);    <span class=\"comment\">// 在迭代器 p 所指元素之前添加 n 个 t</span></span><br><span class=\"line\">c.<span class=\"built_in\">insert</span>(p, b, e);    <span class=\"comment\">// 在迭代器 p 所指元素之前添加迭代器范围 [b,e) 中的元素。</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>9.3.2 访问元素</strong></p>\r\n<p><strong>at/下标</strong></p>\r\n<p>可以快速随机访问的容器都可以使用下标。</p>\r\n<p>使用下标一定要保证下标不越界，可以用 at 函数。当下标越界，at\r\n函数会抛出一个 out_of_range 异常: <code>a.at(n)</code></p>\r\n<p><strong>9.3.3 删除元素</strong></p>\r\n<p>这些操作改变数组大小，故不适用于 array。</p>\r\n<p>pop(front, back), clear 无返回值。</p>\r\n<p>删除返回被删除元素之后元素的迭代器。</p>\r\n<p>vector/string 不支持 <strong>pop_front</strong>，forward_list 不支持\r\n<strong>pop_back。</strong></p>\r\n<p>forward_list 有自己特殊版本的 erase。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">erase</span>(b, e);  <span class=\"comment\">// 删除迭代器范围 [b, e) 内的元素</span></span><br></pre></td></tr></table></figure>\r\n<p>删除 deque 除首尾之外的任何元素都会使所有迭代器、引用和指针失效。删除\r\nvector 或 string\r\n中的元素会使指向删除点之后位置的迭代器、引用和指针失效。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">it = vec.<span class=\"built_in\">erase</span>(it); <span class=\"comment\">// vector 删除写法</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>9.3.4 特殊的forward_list操作</strong></p>\r\n<p>forward_list\r\n是单向链表，添加和删除操作都会同时改变前驱和后继结点，因此一般的添加和删除都不适用于\r\nforward_list。</p>\r\n<p>forward_list 定义了<strong>首前迭代器</strong>：before_begin()\r\n可以返回首前迭代器，用来删除首元素，不能解引用。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">lst.<span class=\"built_in\">insert_after</span>(p,t);     <span class=\"comment\">// 在迭代器 p 之后添加一个元素 t</span></span><br><span class=\"line\">lst.<span class=\"built_in\">insert_after</span>(p,n,t);</span><br><span class=\"line\">lst.<span class=\"built_in\">insert_after</span>(p,b,e);</span><br><span class=\"line\">lst.<span class=\"built_in\">insert_after</span>(p,il);    <span class=\"comment\">// il是花括号列表</span></span><br><span class=\"line\">lst.<span class=\"built_in\">emplace_after</span>(p,args); <span class=\"comment\">// 在 p 之后构建新元素</span></span><br><span class=\"line\"><span class=\"comment\">// 以上操作，返回指向最后一个插入元素的迭代器。若范围为空，返回 p</span></span><br><span class=\"line\">lst.<span class=\"built_in\">erase_after</span>(p);        <span class=\"comment\">// 删除 p 之后的元素，注意 p 不能是尾元素</span></span><br><span class=\"line\">lst.<span class=\"built_in\">erase_after</span>(b,e);      <span class=\"comment\">// 删除迭代器返回 (b,e) 中的元素，注意不包含 b 和 e</span></span><br><span class=\"line\"><span class=\"comment\">// 返回指向最后一个被删除元素之后的迭代器。</span></span><br></pre></td></tr></table></figure>\r\n<p>删除所有奇数：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">forward_list&lt;<span class=\"type\">int</span>&gt; flst = { <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>};</span><br><span class=\"line\"><span class=\"keyword\">auto</span> prev = flst.<span class=\"built_in\">before_begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> curr = flst.<span class=\"built_in\">begin</span>() ;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(curr != flst.<span class=\"built_in\">end</span>()) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*curr &amp; <span class=\"number\">1</span>) curr = flst.<span class=\"built_in\">erase_after</span>(prev);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        prev = curr;</span><br><span class=\"line\">        ++curr;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p><strong>9.3.5 改变容器大小</strong></p>\r\n<p><strong>resize() 用来增大或缩小容器。</strong></p>\r\n<p>如果要求的大小小于当前大小，尾部会被删除，如果要求的大小大于当前大小，会把新元素添加到尾部，旧元素不变。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">v.<span class=\"built_in\">resize</span>(n);   <span class=\"comment\">// 元素类型必须提供一个默认构造函数</span></span><br><span class=\"line\">v.<span class=\"built_in\">resize</span>(n, t);</span><br></pre></td></tr></table></figure>\r\n<p><strong>9.3.6 容器操作可能使迭代器失效</strong></p>\r\n<p>添加和删除元素都可能使指针、引用、迭代器失效。使用失效的指针、引用、迭代器是很严重的错误。</p>\r\n<p><strong>编写改变容器的循环程序</strong></p>\r\n<p>必须保证每次改变容器后都<strong>更新迭代器</strong>。</p>\r\n<p>insert 和 erase 都会返回迭代器，更新很容易。调用 erase\r\n后，<strong>不需要</strong>递增迭代器，调用 insert\r\n后，需要<strong>递增两次</strong>。</p>\r\n<p><strong>不要保存 end() 返回的迭代器</strong></p>\r\n<p>插入删除都会改变尾后迭代器，因此不能保存 end()\r\n返回值作为循环判断条件。</p>\r\n<p><strong>9.4 vector对象是如何增长的</strong></p>\r\n<p>vector 和 string\r\n是连续存储的，为了避免每增加一个元素就要重新分配一次空间，在每次必须获取新的内存空间时，通常会分配比新的空间需求更大的内存空间。容器预留多的空间作为备用。这种方法在实现时性能很好，虽然每次重新分配内存都要移动所有元素，但是其<strong>扩张操作通常比\r\nlist 和 deque 还快</strong>。</p>\r\n<p><strong>管理容量</strong></p>\r\n<p><strong>c.capacity(), c.reserve(), c.shrink_to_fit</strong> 都适用于\r\nvector 和 string，c.shrink_to_fit 还另外适用于 deque。</p>\r\n<p>​ c.capacity(); // 不重新分配内存空间的话，c 可以保存多少元素。\r\nc.reserve(n); // 分配至少能容纳 n 个元素的空间（只预分配内存）\r\nc.shrink_to_fit(); // 请求将 capacity() 减少为与 size() 相同大小。</p>\r\n<p>c.reserve(n)\r\n不会减小容量，只会增大容量，当需求容量大于当前容量，才会分配内存，否则什么都不做。</p>\r\n<p>c.shrink_to_fit() 只是一个请求，，实现时标准库可能会不执行。</p>\r\n<p><strong>9.5 额外的string操作</strong></p>\r\n<p><strong>9.5.1 构造string的其他方法</strong></p>\r\n<p><strong>构造string的基础方法</strong></p>\r\n<p>string 不支持在初始化时接受一个数字以指定 string\r\n的大小。如果想要指定大小，可以先默认初始化，再调用 resize()\r\n函数调整大小。</p>\r\n<p><strong>构造string的其他方法</strong></p>\r\n<p>string 的构造函数可以接受一个 <strong>string</strong> 或\r\n<strong>const char*</strong>\r\n参数用来指定开始位置，然后接受一个<strong>计数值</strong>用来指定范围。</p>\r\n<p>如果没有传递计数值用来确定范围，拷贝操作遇到空字符停止：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *cp = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> noNull[] = {<span class=\"string\">'H'</span>, <span class=\"string\">'i'</span>};</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s1</span><span class=\"params\">(cp)</span></span>;     <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s2</span><span class=\"params\">(noNull)</span></span>; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\r\n<p>开始位置必须保证是在拷贝对象的范围内，计数值也没有上限要求，当计数值指定的范围大于拷贝对象，就最多拷贝到结尾。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(cp, n)</span></span>;          <span class=\"comment\">// cp 是一个字符数组，s 是 cp 指向的字符数组前 n 个字符的拷贝</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(s2, pos2)</span></span>;       <span class=\"comment\">// s2 是一个 string 对象，s 是从 s2 的下标 pos 处开始到最后的字符的拷贝</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(s2, pos2, len2)</span></span>; <span class=\"comment\">// s 是从 s2 的下标 pos2 处开始的 len2 个字符的拷贝。              </span></span><br></pre></td></tr></table></figure>\r\n<p><strong>substr</strong></p>\r\n<p><strong>s.substr(pos, (n))</strong> 返回 s\r\n的一个子序列，范围由参数指定。</p>\r\n<p>如果 pos 的值超过了 string 的大小，则 substr 函数会抛出一个\r\nout_of_range 异常；若 pos+n 的值超过了 string 的大小，则 substr 会调整 n\r\n的值，只拷贝到 string 的末尾。</p>\r\n<p><strong>9.5.2 改变string的其他方法</strong></p>\r\n<p>string 支持顺序容器的 assign、insert、erase\r\n操作，此外还增加了两个额外的操作</p>\r\n<ol type=\"1\">\r\n<li>接受下标版本的 insert 和 erase</li>\r\n<li>接受 C 风格字符数组的 insert 和 assign</li>\r\n<li>append 和 replace 函数</li>\r\n</ol>\r\n<p><strong>接受下标的 insert 和 erase</strong></p>\r\n<p>insert 和 erase 接受下标的版本返回的是一个指向 s\r\n的引用（区别于迭代器版本返回指向第一个插入字符的迭代器）</p>\r\n<p>insert 的所有版本都是第一部分参数为 pos，后面的参数为待插入的字符</p>\r\n<p>erase 的所有版本的参数都是 pos，pos 分为 起始位置 和\r\n终止位置/长度</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.<span class=\"built_in\">insert</span>(s.<span class=\"built_in\">size</span>(), <span class=\"number\">5</span>, <span class=\"string\">'!'</span>);       <span class=\"comment\">// 在 s 末尾（s[s.size()]之前）插入 5 个感叹号</span></span><br><span class=\"line\">s.<span class=\"built_in\">insert</span>(<span class=\"number\">0</span>, s2, <span class=\"number\">3</span>, s2.<span class=\"built_in\">size</span>()<span class=\"number\">-3</span>);  <span class=\"comment\">// 在 s[0] 之前插入 s2 第四个字符开始的 s2.size()-3 个字符</span></span><br><span class=\"line\">s.<span class=\"built_in\">erase</span>(s.<span class=\"built_in\">size</span>()<span class=\"number\">-5</span>, <span class=\"number\">5</span>);           <span class=\"comment\">// 从 s 删除最后 5 个字符         </span></span><br></pre></td></tr></table></figure>\r\n<p><strong>接受 C 风格字符数组的 insert 和 assign</strong></p>\r\n<p>assign 的所有版本的参数都是要赋的值，由 起始位置 + 终止位置/长度\r\n组成</p>\r\n<p>replace\r\n的所有版本的参数都是第一部分参数为要删除的范围，第二部分为要插入的字符。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* cp = <span class=\"string\">\"stately,plump Buck\"</span>;</span><br><span class=\"line\">s.<span class=\"built_in\">assign</span>(cp, <span class=\"number\">7</span>);             <span class=\"comment\">// 用从 cp 开始的前 7 个字符向 s 赋值</span></span><br><span class=\"line\">s.<span class=\"built_in\">insert</span>(s.<span class=\"built_in\">size</span>(), cp+<span class=\"number\">7</span>);    <span class=\"comment\">// 将从 cp+7 开始到 cp 末尾的字符插入到 s 末尾</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>append 和 replace</strong></p>\r\n<p>append：在 string\r\n末尾进行插入操作的简写形式：<code>s.append(\" 4th Ed.\");</code></p>\r\n<p>replace：调用 erase 和 insert\r\n操作的简写形式：<code>s.replace(11, 3, \"Fifth\");</code> 从下标 11\r\n开始，删除三个字符并插入 5 个新字符。</p>\r\n<p><strong>9.5.3 string搜索操作</strong></p>\r\n<p>string 类提供了 6 个不同的搜索函数，每个函数有 4 个重载版本。</p>\r\n<p>搜索操作返回 string::size_type 类型，代表匹配位置的下标。</p>\r\n<p>搜索失败则返回一个名为 string::npos 的 static 成员，值初始化为\r\n<strong>-1</strong>。因为 npos 是一个 unsigned 类型，这个初始值意味着\r\nnpos 等于任何 string 最大的可能大小。</p>\r\n<p>注意：find 和 rfind 查找的是给定的整个 args，而剩下的查找的是给定的\r\nargs 中包含的任意一个字符。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.<span class=\"built_in\">find</span>(args);               <span class=\"comment\">// 查找 s 中 args 第一次出现的位置</span></span><br><span class=\"line\">s.<span class=\"built_in\">rfind</span>(args);              <span class=\"comment\">// 查找 s 中 args 最后一次出现的位置</span></span><br><span class=\"line\">s.<span class=\"built_in\">find_first_of</span>(args);      <span class=\"comment\">// 查找 s 中 args 的任意一个字符第一次出现的位置</span></span><br><span class=\"line\">s.<span class=\"built_in\">find_last_of</span>(args);       <span class=\"comment\">// 查找 s 中 args 的任意一个字符最后一次出现的位置</span></span><br><span class=\"line\">s.<span class=\"built_in\">find_first_not_of</span>(args);  <span class=\"comment\">// 查找 s 中第一个不在 args 中的字符</span></span><br><span class=\"line\">s.<span class=\"built_in\">find_last_not_of</span>(args);   <span class=\"comment\">// 查找 s 中最后一个不在 args 中的字符</span></span><br><span class=\"line\"><span class=\"string\">'args为以下形式'</span></span><br><span class=\"line\">c,pos        <span class=\"comment\">// 字符，pos 为搜索开始位置</span></span><br><span class=\"line\">s2,pos       <span class=\"comment\">// 字符串</span></span><br><span class=\"line\">cp,pos       <span class=\"comment\">// 以空字符结尾的 c 风格字符串</span></span><br><span class=\"line\">cp,pos,n     <span class=\"comment\">// c 风格字符串的前 n 个字符          </span></span><br></pre></td></tr></table></figure>\r\n<p><strong>9.5.4 compare函数</strong></p>\r\n<p>用于比较两个字符串，可以是比较整个或一部分字符串。</p>\r\n<p>小于返回负数，大于返回正数，等于返回零</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int F = s.compare(s2);</span><br><span class=\"line\">int F = s.compare(pos1,n1,s2);          // 将 s 中 pos1 开始的前 n1 个字符与 s2 比较</span><br><span class=\"line\">int F = s.compare(pos1,n1,s2,pos2,n2);  // 将 s 中 pos1 开始的前 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较 </span><br><span class=\"line\">int F = s.compare(cp)                   // 将 s 与 cp 指向的字符数组比较</span><br><span class=\"line\">int F = s.compare(pos1,n1,cp);</span><br><span class=\"line\">int F = s.compare(pos1,n1,cp,n2);              </span><br></pre></td></tr></table></figure>\r\n<p><strong>9.5.5 数值转换</strong></p>\r\n<p>stoi 中要转换的 string 的第一个非空白符必须是数字或\r\n\"+\"、\"-\"、\".\"，可以以 0x 或 0X 开头表示十六进制数，可以以 e 或\r\nE表示指数部分。</p>\r\n<p>stod, stold</p>\r\n<p><strong>9.6 容器适配器</strong></p>\r\n<p><strong>初始化操作</strong></p>\r\n<p>默认情况下，stack 和 queue 是基于 deque 实现的， priority_queue 是在\r\nvector 之上实现的。</p>\r\n<p><strong>初始化操作</strong>：</p>\r\n<p>如果要使用其他顺序容器实现适配器，要在创建适配器时用一个顺序容器作为第二个类型参数。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">stack&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;&gt; sta;  <span class=\"comment\">// 定义基于 vector 实现的 stack</span></span><br></pre></td></tr></table></figure>\r\n<p>stack 可以构造于 <strong>vector, list, deque</strong> 之上。</p>\r\n<p>queue 可以构造于 <strong>list, deque</strong>\r\n之上。<code>queue q(dq);</code></p>\r\n<p>priority_queue 可以构造于 <strong>vector(有序)、deque</strong>\r\n之上。</p>\r\n"},{"title":"cppprimer第八章","url":"/posts/81ae541d/","content":"<p><strong>第8章 IO库</strong></p>\r\n<span id=\"more\"></span>\r\n<p><strong>8.1 IO类</strong></p>\r\n<p>IO 库类型定义在三个头文件中：</p>\r\n<ol type=\"1\">\r\n<li><strong>iostream：</strong>定义了读写流的类型：istream, ostream,\r\niostream, wistream, wostream, wiostream</li>\r\n<li><strong>fstream：</strong>读写命名文件的类型：ifstream, ofstream,\r\nfstream, wifstream, wofstream, wfstream</li>\r\n<li><strong>sstream：</strong>读写内存 string 对象的类型：istringstream,\r\nostringstream, stringstream</li>\r\n</ol>\r\n<p>其中带 w\r\n前缀的类型用来操作<strong>宽字符语言(wchar_t)</strong>。宽字符版本的类型和函数前都有一个\r\nw，如 wcin, wcout, wcerr。</p>\r\n<p>fstream 和 sstream 中的类型都继承自 iostream 中的类型。</p>\r\n<p>可以将一个派生类对象当成基类对象来使用。</p>\r\n<p><strong>8.1.1 IO对象无拷贝或赋值</strong></p>\r\n<p><strong>不能拷贝或对 IO\r\n对象赋值</strong>，因此也不能将形参或返回类型设置成流类型。</p>\r\n<p>进行 IO 操作的函数通常<strong>以引用形式传递和返回流</strong>。读写\r\nIO 对象会改变其状态，因此引用不能是 const 的。</p>\r\n<p><strong>8.1.2 条件状态</strong></p>\r\n<p>IO\r\n操作的问题是可能发生错误。<strong>因此在使用一个流之前，应该先检查它是否处于良好状态</strong>。</p>\r\n<p><strong>条件状态</strong>用来查看流的状态。</p>\r\n<p><strong>IO 库的状态</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">iostream::iostate;<span class=\"comment\">//作为位集合来使用，可以表达流的完整状态。通过位运算符可以一次性检测或设置多个标志位。</span></span><br><span class=\"line\">iostream::badbit; cin.badbit;<span class=\"comment\">//表示流已崩溃，是系统及错误或不可恢复的读写错误。流无法再使用。</span></span><br><span class=\"line\">iostream::failbit; cin.failbit;<span class=\"comment\">//表示一个 IO 操作失败了，是可恢复错误。修正后流可以继续使用。</span></span><br><span class=\"line\">iostream::eofbit; cin.eofbit;<span class=\"comment\">//表示流到达了文件结束</span></span><br><span class=\"line\">iostream::goodbit;<span class=\"comment\">//表示流未处于错误状态</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>检查流的状态</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(cin &gt;&gt; word);<span class=\"comment\">// &gt;&gt; 表达式返回流的状态</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>管理条件状态</strong></p>\r\n<p>​ cin.rdstate();//返回一个 iostate 值表示当前状态。\r\ncin.setstate(state);//接受一个 iostate 类型的参数，将给定条件位置位。\r\ncin.clear();//清除（复位）所有错误标志位，cin.clear() 后，cin.good()\r\n会返回 true cin.clear(state);//接受一个 iostate\r\n类型的参数，设为流的新状态。</p>\r\n<p><strong>设置某个标志位的方式</strong></p>\r\n<p>​ cin.clear(cin.rdstate() &amp; ~cin.failbit);//将 failbit 复位</p>\r\n<p><strong>8.1.3 管理输出缓冲</strong></p>\r\n<p>每个输出流都管理一个缓冲区。</p>\r\n<p><strong>缓冲刷新（即数据真正写到设备或文件）的原因：</strong></p>\r\n<ol type=\"1\">\r\n<li>程序正常结束，比如执行到了 return。</li>\r\n<li>缓冲区满了</li>\r\n<li>使用操纵符如 <strong>endl, flush, ends</strong>\r\n来显示刷新缓冲区</li>\r\n<li>当读写被关联的流时，如读 cin 或写 cerr 都会刷新 cout 的缓冲区</li>\r\n<li>使用操纵符 unitbuf 设置流的内部状态来清空缓冲区。</li>\r\n</ol>\r\n<p><strong>操纵符</strong> <strong>endl, flush, ends</strong></p>\r\n<p>​ cout &lt;&lt; a &lt;&lt; endl;//输出 a 和一个换行，然后刷新缓冲区\r\ncout &lt;&lt; a &lt;&lt; flush;//输出 a，然后刷新缓冲区 cout &lt;&lt; a\r\n&lt;&lt; ends;//输出 a 和一个空字符，然后刷新缓冲区</p>\r\n<p><strong>操纵符</strong> <strong>unitbuf, nounitbuf</strong></p>\r\n<ul>\r\n<li><strong>unitbuf：</strong>告诉流接下来每次写操作之后都进行一次 flush\r\n操作</li>\r\n<li><strong>nounitbuf：</strong>重置流，恢复正常的刷新机制</li>\r\n</ul>\r\n<p>​ cout &lt;&lt; unitbuf; //后面的所有输出操作都会立即刷新缓冲区 cout\r\n&lt;&lt; nounitbuf; //回到正常的缓冲方式</p>\r\n<p>注意：如果程序异常终止，将不会刷新缓冲区，即此时相应的输出操作已执行但没有打印。</p>\r\n<p><strong>关联输入和输出流</strong></p>\r\n<p>当一个输入流关联到一个输出流，每次从该输入流读取数据前都会先刷新关联的输出流。</p>\r\n<p>标准库将 cin 和 cout 关联在一起。</p>\r\n<p>输入流的成员函数 <strong>tie</strong>\r\n可以用来查看关联的输出流或关联到输出流：</p>\r\n<p>​ cin.tie();//返回指向关联到 cin\r\n的输出流的指针，如果没有关联的输出流，返回空指针。\r\ncin.tie(&amp;cerr);//接受一个指向输出流 cerr 的指针作为参数，将 cin 与\r\ncerr 关联在一起 cin.tie(NULL);//cin 不再与其他流关联</p>\r\n<p>每个流最多关联到一个输出流，但一个输出流可以被多个流关联。</p>\r\n<p><strong>8.2 文件输入输出</strong></p>\r\n<p>头文件 fstream 中定义的 ifstream, ofstream, fstream\r\n类型用来对文件进行读写。</p>\r\n<p>当要读写一个文件时，创建一个文件流对象并将之绑定到该文件。</p>\r\n<p><strong>8.2.1 使用文件流对象</strong></p>\r\n<p>C++11 中，文件名可以是 string 类型对象，也可以是 C 风格字符串</p>\r\n<p><strong>fstream 定义和初始化</strong></p>\r\n<p>​ fstream fs; // 创建一个未绑定的文件流 fs fstream fs('data.txt'); //\r\n创建一个绑定到文件 data.txt 的文件流 fs,并打开文件 data.txt fstream\r\nfs('data.txt', mode); // 与上一个构造函数类似，但是按指定模式 mode\r\n打开文件</p>\r\n<p><strong>fstream 特有操作</strong></p>\r\n<p>​ getline(ifs, s); // 从一个输入流 ifs 读取一行字符串存入 s 中\r\nfs.open('data.ext'); // 将 fs 与文件 data.txt\r\n绑定并打开该文件。如果已打开会发生错误。 fs.close(); // 关闭 fs\r\n绑定的文件。 fs.is_open(); // 返回一个 bool\r\n值，指出关联文件是否成功打开。</p>\r\n<p>当定义了一个空的文件流对象，使用 open\r\n函数将其与文件关联并打开文件。</p>\r\n<p>如果 open 失败，failebit 会被置位，<strong>建议每次 open 后检测 open\r\n是否成功。</strong></p>\r\n<p>不能对已打开的文件流调用 open。</p>\r\n<p>当文件关闭后，可以将文件流关联到另一个文件。</p>\r\n<p>当一个 fstream 对象被销毁时，close 函数会自动被调用。</p>\r\n<p><strong>用 fstream 代替 iostream</strong></p>\r\n<p>使用 iostream 类型的引用作为函数参数的地方，都可以使用 fstream\r\n来代替。</p>\r\n<p><strong>8.2.2 文件模式</strong></p>\r\n<p>每次打开文件都以某种模式打开，如未指定即以该文件流类型的默认模式打开。</p>\r\n<p>每个流都有一个关联的文件模式，用来指出如何使用文件</p>\r\n<ul>\r\n<li>in：以只读方式打开</li>\r\n<li>out：以只写方式打开</li>\r\n<li><strong>app：</strong>每次写操作前均定位到文件末尾</li>\r\n<li><strong>ate：</strong>打开文件后即定位到文件末尾</li>\r\n<li><strong>trunc：</strong>截断文件</li>\r\n<li>binary：以二进制方式进行 IO</li>\r\n</ul>\r\n<p><strong>文件模式的使用：</strong></p>\r\n<ul>\r\n<li>每个流对象都有默认的文件模式，ifstream 默认 in\r\n模式打开文件，ofstream 默认 out，fstream 默认 in 和 out。</li>\r\n<li>对 ifstream 对象不能设置 out 模式，对 ofstream 对象不能设置 in\r\n模式</li>\r\n<li>只有设置了 out 才能设置 trunc 模式，只设置 out 模式会默认也设置\r\ntrunc 模式</li>\r\n<li>设置了 trunc 就不能再设置 app 模式</li>\r\n<li><strong>默认情况下以 out\r\n模式打开文件会使文件内容被清空</strong>，如果要保留文件内容需要同时指定\r\napp 模式或 in 模式。</li>\r\n<li>app 模式下，会将写入的数据追加写到文件末尾</li>\r\n</ul>\r\n<p>​ ofstream fout(\"file1.txt\"); //\r\n以输出模式打开文件并截断文件（即清空文件内容） ofstream\r\nfout(\"file1.txt\", ofstream::app); // 显示指定 app 模式（+隐含的 out\r\n模式） ofstream fout(\"file1.txt\", ofstream::app | ofstream::out); //\r\n同上，只是将 out 模式显式地指定了一下。 fout.open(\"file1.txt\",\r\nofstream::out);</p>\r\n<p><strong>8.3 string流</strong></p>\r\n<p>sstream 定义了 <strong>istringstream, ostringstream,\r\nstringstream</strong> 来读写 string。</p>\r\n<p><strong>sstream 定义和初始化</strong></p>\r\n<p>​ stringstream strm(); // 定义一个未绑定的 stringstream 对象\r\nstringstream strm(s); // 定义一个 stringstream 对象 strm，strm 中保存着\r\nstring s 的拷贝。</p>\r\n<p><strong>8.3.1 使用istringstream</strong></p>\r\n<p><strong>stringstream 特有操作</strong></p>\r\n<p>​ strm.str(); // 返回 strm 中保存的 str 的拷贝 strm.str(s); // 将\r\nstring s 拷贝到 strm 中，返回 void</p>\r\n<p><strong>8.3.2 使用ostringstream</strong></p>\r\n<p>理解：</p>\r\n<ol type=\"1\">\r\n<li>istringstream\r\n是输入流，即读操作，要将流中的内容输入到字符串中，因此定义和使用\r\nistringstream\r\n时流内必须有内容，所以在使用前要提前在流内保存一个字符串</li>\r\n<li>ostringstream\r\n是输出流，即写操作，将流中的内容输出到字符串中，ostringstream\r\n可以在定义时即在流中保存一个字符串，也可以通过 &lt;&lt;\r\n操作符获得字符串。</li>\r\n</ol>\r\n","categories":["c++"],"tags":["c++ primer"]},{"title":"cppprimer第十三章","url":"/posts/f748fdcf/","content":"<span id=\"more\"></span>\r\n<h1 id=\"第十三章-拷贝控制\">第十三章 拷贝控制</h1>\r\n<p><strong>拷贝控制操作</strong>（copy control）:</p>\r\n<ul>\r\n<li>拷贝构造函数（copy constructor）</li>\r\n<li>拷贝赋值运算符（copy-assignment operator）</li>\r\n<li>移动构造函数（move constructor）</li>\r\n<li>移动赋值函数（move-assignement operator）</li>\r\n<li>析构函数（destructor）</li>\r\n</ul>\r\n<h2 id=\"拷贝赋值和销毁\">拷贝、赋值和销毁</h2>\r\n<h3 id=\"拷贝构造函数\">拷贝构造函数</h3>\r\n<ul>\r\n<li>如果一个构造函数的第一个参数是<strong>自身类类型的引用</strong>，且任何额外参数都有默认值，则此构造函数是<strong>拷贝构造函数</strong>。</li>\r\n<li>引用的原因：传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。</li>\r\n<li><code>class Foo{ public: Foo(const Foo&amp;); }</code></li>\r\n<li><strong>合成的拷贝构造函数</strong>（synthesized copy\r\nconstructor）：会将参数的成员逐个拷贝到正在创建的对象中。</li>\r\n<li><strong>拷贝初始化</strong>：\r\n<ul>\r\n<li>将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。</li>\r\n<li>通常使用拷贝构造函数完成。</li>\r\n<li><code>string book = \"9-99\";</code></li>\r\n<li>出现场景：\r\n<ul>\r\n<li>用<code>=</code> <strong>定义</strong>变量时。</li>\r\n<li>将一个对象作为实参传递给一个非引用类型的形参。</li>\r\n<li>从一个返回类型为非引用类型的函数返回一个对象。</li>\r\n<li>用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。花括号内元素个数是拷贝构造次数。</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"拷贝赋值运算符\">拷贝赋值运算符</h3>\r\n<ul>\r\n<li><strong>重载赋值运算符</strong>：\r\n<ul>\r\n<li>重写一个名为<code>operator=</code>的函数.</li>\r\n<li>通常返回一个指向其左侧运算对象的引用。</li>\r\n<li><code>Foo&amp; operator=(const Foo&amp;);</code></li>\r\n</ul></li>\r\n<li><strong>合成拷贝赋值运算符</strong>：\r\n<ul>\r\n<li>一个类未定义自己的拷贝赋值运算符，默认生成。</li>\r\n<li>将右侧运算对象的每个非<code>static</code>成员赋予左侧运算对象的对应成员。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"析构函数\">析构函数</h3>\r\n<ul>\r\n<li>释放对象所使用的资源，并销毁对象的非<code>static</code>数据成员。</li>\r\n<li>名字由波浪号接类名构成。没有返回值，也不接受参数。</li>\r\n<li><code>~Foo();</code></li>\r\n<li>调用时机：\r\n<ul>\r\n<li>变量在离开其作用域时。</li>\r\n<li>当一个对象被销毁时，其成员被销毁。</li>\r\n<li>容器被销毁时，其元素被销毁。</li>\r\n<li>动态分配的对象，当对指向它的指针应用<code>delete</code>运算符时。</li>\r\n<li>对于临时对象，当创建它的完整表达式结束时。</li>\r\n</ul></li>\r\n<li><strong>合成析构函数</strong>：\r\n<ul>\r\n<li>空函数体执行完后，<strong>成员会被自动销毁。</strong></li>\r\n<li>注意：析构函数体本身并不直接销毁成员。</li>\r\n<li>合成析构函数并不删除指针成员所指向的对象，它需要程序员显式编写析构函数去处理。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"三五法则\">三/五法则</h3>\r\n<ul>\r\n<li><p>需要析构函数的类也需要拷贝和赋值操作。</p>\r\n<ul>\r\n<li>一个对象拥有额外的资源（指针指向的内存），但另一个对象使用默认的拷贝构造函数也同时拥有这块资源。当一方对象被销毁后，析构函数释放了资源，这时另一个对象便失去了这块资源。</li>\r\n</ul></li>\r\n<li><p>需要拷贝操作的类也需要赋值操作，反之亦然。</p></li>\r\n<li><p>13.1.4练习</p>\r\n<ul>\r\n<li><p>合成拷贝构造函数被调用时简单复制序号，使得三个对象具有相同的序号。1\r\n1 1</p></li>\r\n<li><p>定义变量和函数传参时，两次调用拷贝构造函数。4 5 6</p></li>\r\n<li><p>引用，不拷贝。1 2 3</p></li>\r\n<li><p>```cpp<br>\r\n#include <iostream><br>\r\nint unique;</iostream></p>\r\n<p>class numbered {<br>\r\npublic:<br>\r\nnumbered() {mysn = ++unique;}<br>\r\n// numbered(numbered &amp;d): mysn(++unique) {}</p>\r\n<pre><code>  int mysn;</code></pre>\r\n<p>};</p>\r\n<p>void f(numbered s) {<br>\r\nstd::cout &lt;&lt; s.mysn &lt;&lt; std::endl;<br>\r\n}</p>\r\n<p>int main() {<br>\r\nnumbered a, b = a, c = b;<br>\r\nf(a);<br>\r\nf(b);<br>\r\nf(c);<br>\r\n}<br>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 使用=default</span><br><span class=\"line\"></span><br><span class=\"line\">- 可以通过将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本。</span><br><span class=\"line\">- 合成的函数将隐式地声明为内联的。</span><br><span class=\"line\"></span><br><span class=\"line\">### 阻止拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">- 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</span><br><span class=\"line\">- 定义删除的函数：`=delete`。</span><br><span class=\"line\">- 虽然声明了它们，但是不能以任何方式使用它们。</span><br><span class=\"line\">- 析构函数不能是删除的成员。</span><br><span class=\"line\">- 如果一个类有数据成员不能默认构造、拷贝、复制或者销毁，则对应的成员函数将被定义为删除的。</span><br><span class=\"line\">- 老版本使用`private`声明来阻止拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">## 拷贝控制和资源管理</span><br><span class=\"line\"></span><br><span class=\"line\">- 类的行为可以像一个值，也可以像一个指针。</span><br><span class=\"line\">  - 行为像值：对象有自己的状态，副本和原对象是完全独立的。</span><br><span class=\"line\">  \t- 编写赋值运算符：如果将一个对象赋予它自身，赋值运算符必须能正确工作。</span><br><span class=\"line\">  - 行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。</span><br><span class=\"line\"></span><br><span class=\"line\">## 交换操作</span><br><span class=\"line\"></span><br><span class=\"line\">- 管理资源的类通常还定义一个名为`swap`的函数。   </span><br><span class=\"line\">- 经常用于重排元素顺序的算法。</span><br><span class=\"line\">- 用`swap`而不是`std::swap`。</span><br><span class=\"line\"></span><br><span class=\"line\">## 对象移动</span><br><span class=\"line\"></span><br><span class=\"line\">- 很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。</span><br><span class=\"line\">- 在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。</span><br><span class=\"line\">- 标准库容器、`string`和`shared_ptr`类既可以支持移动也支持拷贝。`IO`类和`unique_ptr`类可以移动但不能拷贝。</span><br><span class=\"line\"></span><br><span class=\"line\">### 右值引用</span><br><span class=\"line\"></span><br><span class=\"line\">- 新标准引入右值引用以支持移动操作。</span><br><span class=\"line\">- 通过`&amp;&amp;`获得右值引用。</span><br><span class=\"line\">- 只能绑定到一个将要销毁的对象，右值引用变量不能直接绑定到右值引用上。</span><br><span class=\"line\">- 常规引用可以称之为左值引用。</span><br><span class=\"line\">- 左值持久，右值短暂。</span><br><span class=\"line\"></span><br><span class=\"line\">**move函数**：</span><br><span class=\"line\"></span><br><span class=\"line\">- `int &amp;&amp;rr2 = std::move(rr1);`</span><br><span class=\"line\">- `qmove`告诉编译器，我们有一个左值，但我希望像右值一样处理它。</span><br><span class=\"line\">- 调用`move`意味着：除了对`rr1`赋值或者销毁它外，我们将不再使用它。</span><br><span class=\"line\"></span><br><span class=\"line\">### 移动构造函数和移动赋值运算符</span><br><span class=\"line\"></span><br><span class=\"line\">- **移动构造函数**：</span><br><span class=\"line\">  </span><br><span class=\"line\">  - 第一个参数是该类类型的一个引用，关键是，这个引用参数是一个**右值引用**。</span><br><span class=\"line\">  </span><br><span class=\"line\">  - ```cpp</span><br><span class=\"line\">  \tStrVec::StrVec(StrVec &amp;&amp;s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) {</span><br><span class=\"line\">  \t    // 置于可析构状态</span><br><span class=\"line\">  \t    s.elements = s.first_free = s.cap = nullptr;</span><br><span class=\"line\">  \t    // 然后析构</span><br><span class=\"line\">  \t}</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>不分配任何新内存，只是接管给定的内存。</p></li>\r\n</ul></li>\r\n<li><p><strong>移动赋值运算符</strong>：</p>\r\n<ul>\r\n<li><code>StrVec&amp; StrVec::operator=(StrVec &amp;&amp; rhs) noexcept{}</code></li>\r\n<li>检测自赋值的情况</li>\r\n</ul></li>\r\n<li><p>移动右值(移动构造函数)，拷贝左值(拷贝构造函数)。</p></li>\r\n<li><p>如果没有移动构造函数，右值也被拷贝。</p></li>\r\n<li><p>拷贝并交换赋值运算符：根据实参类型，既可拷贝又可移动。</p></li>\r\n<li><p>更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</p></li>\r\n<li><p>移动迭代器：</p>\r\n<ul>\r\n<li><code>make_move_iterator</code>函数将一个普通迭代器转换为一个移动迭代器。</li>\r\n</ul></li>\r\n<li><p>建议：小心地使用移动操作，以获得性能提升。</p></li>\r\n</ul>\r\n<h3 id=\"右值引用和成员函数\">右值引用和成员函数</h3>\r\n<ul>\r\n<li>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code>。</li>\r\n<li>引用限定符：\r\n<ul>\r\n<li>在参数列表后面加一个<code>&amp;</code>，限定只能向可修改的左值赋值而不能向右值赋值。加&amp;&amp;同理。</li>\r\n</ul></li>\r\n</ul>\r\n"},{"title":"cppprimer第十四章","url":"/posts/4065e4aa/","content":"<h4 id=\"练习14.3string和vector都定义了重载的以比较各自的对象假设svec1和svec2是存放string的vector确定在下面的表达式中分别使用了哪个版本的a-应用了c语言内置版本的比较两个指针\">练习14.3：string和vector都定义了重载的==以比较各自的对象，假设svec1和svec2是存放string的vector，确定在下面的表达式中分别使用了哪个版本的==？(a)\r\n应用了C++语言内置版本的==，比较两个指针。</h4>\r\n<span id=\"more\"></span>\r\n<h1 id=\"第十四章-重载运算与类型转换\">第十四章 重载运算与类型转换</h1>\r\n<h2 id=\"基本概念\">基本概念</h2>\r\n<ul>\r\n<li>重载运算符是具有特殊名字的函数：由关键字<code>operator</code>和其后要定义的运算符号共同组成。</li>\r\n<li>当一个重载的运算符是成员函数时，<code>this</code>绑定到左侧运算对象。动态运算符符函数的参数数量比运算对象的数量<strong>少一个</strong>。</li>\r\n<li>只能重载大多数的运算符，而不能发明新的运算符号。</li>\r\n<li>重载运算符的优先级和结合律跟对应的内置运算符保持一致。</li>\r\n<li>是否是成员函数：\r\n<ul>\r\n<li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li>\r\n<li>复合赋值运算符一般来说是成员。</li>\r\n<li>改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。</li>\r\n<li>具有对称性的运算符如算术、相等性、关系、输入输出和位运算符等，通常是非成员函数。</li>\r\n</ul></li>\r\n</ul>\r\n<p><strong>运算符</strong>:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 68%\">\r\n<col style=\"width: 31%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>可以被重载</th>\r\n<th>不可以被重载</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>,\r\n<code>%</code>, <code>^</code></td>\r\n<td><code>::</code>, <code>.*</code>, <code>.</code>,\r\n<code>? :</code>,</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>&amp;</code>, <code>|</code>, <code>~</code>, <code>!</code>,\r\n<code>,</code>, <code>=</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,\r\n<code>&gt;=</code>, <code>++</code>, <code>--</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>==</code>,\r\n<code>!=</code>, <code>&amp;&amp;</code>, <code>||</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>%=</code>,\r\n<code>^=</code>, <code>&amp;=</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>|=, <code>*=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>,\r\n<code>[]</code>, <code>()</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>-&gt;</code>, <code>-&gt;*</code>, <code>new</code>,\r\n<code>new[]</code>, <code>delete</code>, <code>delete[]</code></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"输入和输出运算符\">输入和输出运算符</h2>\r\n<h3 id=\"重载输出运算符\">重载输出运算符&lt;&lt;</h3>\r\n<ul>\r\n<li>第一个形参通常是一个非常量的<code>ostream</code>对象的引用。非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个<code>ostream</code>对象。</li>\r\n<li>输入输出运算符必须是非成员函数。</li>\r\n</ul>\r\n<h3 id=\"重载输入运算符\">重载输入运算符&gt;&gt;</h3>\r\n<ul>\r\n<li>第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。</li>\r\n<li>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li>\r\n</ul>\r\n<h2 id=\"算数和关系运算符-\">算数和关系运算符（+、-、*、/）</h2>\r\n<ul>\r\n<li>如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。</li>\r\n</ul>\r\n<h3 id=\"相等运算符\">相等运算符==</h3>\r\n<ul>\r\n<li>如果定义了<code>operator==</code>，则这个类也应该定义<code>operator!=</code>。</li>\r\n<li>相等运算符和不等运算符的一个应该把工作委托给另一个。</li>\r\n<li>相等运算符应该具有传递性。</li>\r\n<li>如果某个类在逻辑上有相等性的含义，则该类应该定义<code>operator==</code>，这样做可以使用户更容易使用标准库算法来处理这个类。</li>\r\n</ul>\r\n<h3 id=\"关系运算符\">关系运算符</h3>\r\n<ul>\r\n<li>如果存在唯一一种逻辑可靠的<code>&lt;</code>定义，则应该考虑为这个类定义<code>&lt;</code>运算符。如果同时还包含<code>==</code>，则当且仅当<code>&lt;</code>的定义和<code>++</code>产生的结果一直时才定义<code>&lt;</code>运算符。</li>\r\n</ul>\r\n<h2 id=\"赋值运算符\">赋值运算符=</h2>\r\n<ul>\r\n<li>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</li>\r\n<li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这么做。这两类运算符都应该返回左侧运算对象的引用。</li>\r\n</ul>\r\n<h2 id=\"下标运算符\">下标运算符[]</h2>\r\n<ul>\r\n<li>下标运算符必须是成员函数。</li>\r\n<li>一般会定义两个版本：\r\n<ul>\r\n<li>1.返回普通引用。</li>\r\n<li>2.类的常量成员，并返回常量引用。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"递增和递减运算符--\">递增和递减运算符（++、--）</h2>\r\n<ul>\r\n<li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。</li>\r\n<li>通常应该被定义成类的成员。</li>\r\n<li>前置运算符应该返回递增或递减后对象的引用。</li>\r\n<li>后置运算符应该返回递增或递减前对象的值，而不是引用。</li>\r\n<li>后置版本接受一个额外的，不被使用的<code>int</code>类型的形参。因为不会用到，所以无需命名。</li>\r\n</ul>\r\n<h2 id=\"成员访问运算符-\">成员访问运算符（*、-&gt;）</h2>\r\n<ul>\r\n<li>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</li>\r\n<li>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</li>\r\n<li>解引用和乘法的区别是一个是一元运算符，一个是二元运算符。</li>\r\n</ul>\r\n<h2 id=\"函数调用运算符\">函数调用运算符</h2>\r\n<ul>\r\n<li>可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。</li>\r\n<li>函数调用运算符必须是成员函数。</li>\r\n<li>一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</li>\r\n<li>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>。</li>\r\n</ul>\r\n<h3 id=\"lambda是函数对象\"><code>lambda</code>是函数对象</h3>\r\n<ul>\r\n<li><code>lambda</code>捕获变量：<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数。</li>\r\n</ul>\r\n<h3 id=\"标准库定义的函数对象\">标准库定义的函数对象</h3>\r\n<p><strong>标准库函数对象</strong>:</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>算术</th>\r\n<th>关系</th>\r\n<th>逻辑</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>plus&lt;Type&gt;</code></td>\r\n<td><code>equal_to&lt;Type&gt;</code></td>\r\n<td><code>logical_and&lt;Type&gt;</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>minus&lt;Type&gt;</code></td>\r\n<td><code>not_equal_to&lt;Type&gt;</code></td>\r\n<td><code>logical_or&lt;Type&gt;</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>multiplies&lt;Type&gt;</code></td>\r\n<td><code>greater&lt;Type&gt;</code></td>\r\n<td><code>logical_not&lt;Type&gt;</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>divides&lt;Type&gt;</code></td>\r\n<td><code>greater_equal&lt;Type&gt;</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>modulus&lt;Type&gt;</code></td>\r\n<td><code>less&lt;Type&gt;</code></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>negate&lt;Type&gt;</code></td>\r\n<td><code>less_equal&lt;Type&gt;</code></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>可以在算法中使用标准库函数对象。</li>\r\n</ul>\r\n<h3 id=\"可调用对象与function\">可调用对象与function</h3>\r\n<p><strong>标准库function类型</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 34%\">\r\n<col style=\"width: 65%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>function&lt;T&gt; f;</code></td>\r\n<td><code>f</code>是一个用来存储可调用对象的空<code>function</code>，这些可调用对象的调用形式应该与类型<code>T</code>相同。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>function&lt;T&gt; f(nullptr);</code></td>\r\n<td>显式地构造一个空<code>function</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>function&lt;T&gt; f(obj)</code></td>\r\n<td>在<code>f</code>中存储可调用对象<code>obj</code>的副本</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>f</code></td>\r\n<td>将<code>f</code>作为条件：当<code>f</code>含有一个可调用对象时为真；否则为假。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>定义为<code>function&lt;T&gt;</code>的成员的类型</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>result_type</code></td>\r\n<td>该<code>function</code>类型的可调用对象返回的类型</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>argument_type</code></td>\r\n<td>当<code>T</code>有一个或两个实参时定义的类型。如果<code>T</code>只有一个实参，则<code>argument_type</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>first_argument_type</code></td>\r\n<td>第一个实参的类型</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>second_argument_type</code></td>\r\n<td>第二个实参的类型</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>例如：声明一个<code>function</code>类型，它可以表示接受两个<code>int</code>，返回一个<code>int</code>的可调用对象。<code>function&lt;int(int, int)&gt;</code></li>\r\n</ul>\r\n<h2 id=\"重载类型转换运算符\">重载、类型转换、运算符</h2>\r\n<h3 id=\"类型转换运算符\">类型转换运算符</h3>\r\n<ul>\r\n<li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：<code>operator type() const;</code></li>\r\n<li>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是<code>const</code>。</li>\r\n<li>避免过度使用类型转换函数。</li>\r\n<li>C++11引入了显式的类型转换运算符。</li>\r\n<li>向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般定义成<code>explicit</code>的。</li>\r\n</ul>\r\n<h3 id=\"避免有二义性的类型转换\">避免有二义性的类型转换</h3>\r\n<ul>\r\n<li>通常，不要为类第几个亿相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。</li>\r\n<li>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</li>\r\n</ul>\r\n<h3 id=\"函数匹配与重载运算符\">函数匹配与重载运算符</h3>\r\n<ul>\r\n<li>如果<code>a</code>是一种类型，则表达式<code>a sym b</code>可能是：\r\n<ul>\r\n<li><code>a.operatorsym(b);</code></li>\r\n<li><code>operatorsym(a,b);</code></li>\r\n</ul></li>\r\n<li>如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</li>\r\n</ul>\r\n"},{"title":"cppprimer第十章","url":"/posts/7e515086/","content":"<h1 id=\"第十章-泛型算法\">第十章 泛型算法</h1>\r\n<span id=\"more\"></span>\r\n<h2 id=\"泛型算法\">泛型算法</h2>\r\n<ul>\r\n<li>泛型算法本身不执行容器操作，只是单独依赖迭代器和迭代器操作实现。</li>\r\n<li>头文件： <code>#include &lt;algorithm&gt;</code>或者\r\n<code>#include &lt;numeric&gt;</code>(算数相关)</li>\r\n<li>必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。</li>\r\n</ul>\r\n<h3 id=\"find\">find</h3>\r\n<ul>\r\n<li><code>vector&lt;int&gt;::const_iterator result = find(vec.begin(), vec.end(), search_value);</code></li>\r\n<li>输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。</li>\r\n</ul>\r\n<h2 id=\"初识泛型算法\">初识泛型算法</h2>\r\n<ul>\r\n<li>理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。</li>\r\n</ul>\r\n<h3 id=\"只读算法\">只读算法</h3>\r\n<ul>\r\n<li><p>只读取范围中的元素，不改变元素。</p></li>\r\n<li><p>如 <code>find</code>和\r\n<code>accumulate</code>（在<code>numeric</code>中定义，求和）</p>\r\n<ul>\r\n<li><code>cpp       accumulate(all(a), 0); // 0 为求和初值       accumulate(all(s), string(\"\")); // 串联字符串，注意不能用 \"\"，const char* 未定义 + 运算符</code></li>\r\n</ul></li>\r\n<li><p><code>find_first_of</code>，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的<code>end</code>迭代器。</p></li>\r\n<li><p>通常最好使用<code>cbegin</code>和<code>cend</code>。</p></li>\r\n<li><p><code>equal</code>：确定两个序列是否保存相同的值：<code>equal(c1.cbegin(), c1.cend(), c2.cbegin())</code>，假定\r\nc2 至少有 c1 长度。</p></li>\r\n</ul>\r\n<h3 id=\"写容器元素的算法\">写容器元素的算法</h3>\r\n<ul>\r\n<li>一些算法将新值赋予序列中的元素。</li>\r\n<li>算法不检查写操作。</li>\r\n<li><code>fill</code>： <code>fill(vec.begin(), vec.end(), 0);</code>\r\n将每个元素重置为0</li>\r\n<li><code>fill_n</code>： <code>fill_n(vec.begin(), 10, 0);</code></li>\r\n<li>插入迭代器<code>back_inserter</code>：\r\n<ul>\r\n<li>用来确保算法有足够的空间存储数据。</li>\r\n<li><code>#include &lt;iterator&gt;</code></li>\r\n<li><code>back_inserter(vec)</code></li>\r\n</ul></li>\r\n<li>拷贝算法<code>copy</code>：</li>\r\n<li>输入：前两个参数指定输入范围，第三个指向目标序列。</li>\r\n<li><code>copy (ilst.begin(), ilst.end(), back_inserter(ivec));</code></li>\r\n<li><code>copy</code>时必须保证目标目的序列至少要包含与输入序列一样多的元素。</li>\r\n</ul>\r\n<h3 id=\"重排容器元素的算法\">重排容器元素的算法</h3>\r\n<ul>\r\n<li>这些算法会重排容器中元素的顺序。</li>\r\n<li>排序算法<code>sort</code>：\r\n<ul>\r\n<li>接受两个迭代器，表示要排序的元素范围。</li>\r\n</ul></li>\r\n<li>消除重复<code>unique</code>：\r\n<ul>\r\n<li>之前要先调用<code>sort</code></li>\r\n<li>返回的迭代器指向最后一个不重复元素之后的位置。</li>\r\n<li>顺序会变，重复的元素被“删除”。</li>\r\n<li>并没有真正删除，真正删除必须使用容器操作。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"定制操作\">定制操作</h2>\r\n<h3 id=\"向算法传递函数\">向算法传递函数：</h3>\r\n<ul>\r\n<li>谓词（<code>predicate</code>）：\r\n<ul>\r\n<li>是一个<strong>可调用的表达式</strong>，返回结果是一个能用作条件的值</li>\r\n<li>一元谓词：接受一个参数</li>\r\n<li>二元谓词：接受两个参数</li>\r\n</ul></li>\r\n<li>例子：\r\n<ul>\r\n<li><code>stable_sort</code>：\r\n<ul>\r\n<li>保留相等元素的原始相对位置。</li>\r\n<li><code>stable_sort(words.begin(), words.end(), isShorter);</code></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lambda表达式\">lambda表达式</h3>\r\n<ul>\r\n<li><p>有时可能希望操作可以接受更多的参数。</p></li>\r\n<li><p><code>lambda</code>表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。</p></li>\r\n<li><p>形式：<code>[capture list](parameter list) -&gt; return type {function body}</code>。</p>\r\n<ul>\r\n<li>其中<code>capture list</code>捕获列表是一个<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。不可忽略。</li>\r\n<li><code>return type</code>是返回类型。可忽略。</li>\r\n<li><code>parameter</code>是参数列表。可忽略。</li>\r\n<li><code>function body</code>是函数体。不可忽略。</li>\r\n<li><code>auto f = [] {return 42;}</code></li>\r\n</ul></li>\r\n<li><p>如果lambda函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。</p></li>\r\n<li><p>例子：</p>\r\n<ul>\r\n<li><code>find_if</code>:\r\n<ul>\r\n<li>接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。</li>\r\n<li><code>auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a){return a.size() &gt;= sz;});</code></li>\r\n</ul></li>\r\n<li><code>for_each</code>：\r\n<ul>\r\n<li>接受一个可调用对象，并对序列中每个元素调用此对象。</li>\r\n<li><code>for_each(wc, words.end(), [](const string &amp;s){cout &lt;&lt; s &lt;&lt; \" \";})</code></li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"lambda捕获和返回\">lambda捕获和返回</h3>\r\n<ul>\r\n<li>定义<code>lambda</code>时会生成一个新的类类型和该类型的一个对象。</li>\r\n<li>默认情况下，从<code>lambda</code>生成的类都包含一个对应该<code>lambda</code>所捕获的变量的数据成员，在<code>lambda</code>对象创建时被初始化。</li>\r\n<li><strong>值捕获</strong>：前提是变量可以拷贝，<code>size_t v1 = 42; auto f = [v1] {return v1;};</code>。</li>\r\n<li><strong>引用捕获</strong>：必须保证在<code>lambda</code>执行时，变量是存在的，<code>auto f2 = [&amp;v1] {return v1;};</code></li>\r\n<li>尽量减少捕获的数据量，尽可能避免捕获指针或引用。</li>\r\n<li><strong>隐式捕获</strong>：让编译器推断捕获列表，在捕获列表中写一个<code>&amp;</code>（引用方式）或<code>=</code>（值方式）。<code>auto f3 = [=] {return v1;}</code></li>\r\n</ul>\r\n<p><strong>lambda捕获列表</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 26%\">\r\n<col style=\"width: 73%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>捕获列表</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>[]</code></td>\r\n<td>空捕获列表。<code>lambda</code>不能使用所在函数中的变量。一个<code>lambda</code>只有在捕获变量后才能使用它们。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>[names]</code></td>\r\n<td><code>names</code>是一个逗号分隔的名字列表，这些名字都是在<code>lambda</code>所在函数的局部变量，捕获列表中的变量都被拷贝，名字前如果使用了<code>&amp;</code>，则采用引用捕获方式。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>[&amp;]</code></td>\r\n<td>隐式捕获列表，采用引用捕获方式。<code>lambda</code>体中所使用的来自所在函数的实体都采用引用方式使用。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>[=]</code></td>\r\n<td>隐式捕获列表，采用值捕获方式。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>[&amp;, identifier_list]</code></td>\r\n<td><code>identifier_list</code>是一个逗号分隔的列表，包含0个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。<code>identifier_list</code>中的名字前面不能使用<code>&amp;</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>[=, identifier_list]</code></td>\r\n<td><code>identifier_list</code>中的变量采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。<code>identifier_list</code>中的名字不能包括<code>this</code>，且前面必须使用<code>&amp;</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"参数绑定\">参数绑定</h3>\r\n<ul>\r\n<li><code>lambda</code>表达式更适合在一两个地方使用的简单操作。</li>\r\n<li>如果是很多地方使用相同的操作，还是需要定义函数。</li>\r\n<li>函数如何包装成一元谓词？使用参数绑定。</li>\r\n<li>标准库<code>bind</code>函数：\r\n<ul>\r\n<li>定义在头文件<code>functional</code>中，可以看做为一个通用的函数适配器。</li>\r\n<li><code>auto newCallable = bind(callable, arg_list);</code></li>\r\n<li>我们再调用<code>newCallable</code>的时候，<code>newCallable</code>会调用<code>callable</code>并传递给它<code>arg_list</code>中的参数。</li>\r\n<li><code>_n</code>代表第n个位置的参数。定义在<code>placeholders</code>的命名空间中。<code>using std::placeholder::_1;</code></li>\r\n<li><code>auto g = bind(f, a, b, _2, c, _1);</code>，调用<code>g(_1, _2)</code>实际上调用<code>f(a, b, _2, c, _1)</code></li>\r\n<li>非占位符的参数要使用引用传参，必须使用标准库<code>ref</code>函数或者<code>cref</code>函数。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"再探迭代器\">再探迭代器</h2>\r\n<h3 id=\"插入迭代器\">插入迭代器</h3>\r\n<ul>\r\n<li>插入器是一种迭代器适配器，接受一个容器，生成一个迭代器，能实现向给定容器添加元素。</li>\r\n<li>三种类型：\r\n<ul>\r\n<li><code>back_inserter</code>：创建一个使用<code>push_back</code>的迭代器。</li>\r\n<li><code>front_inserter</code>创建一个使用<code>push_front</code>的迭代器。</li>\r\n<li><code>inserter</code>创建一个使用<code>insert</code>的迭代器。接受第二个参数，即一个指向给定容器的迭代器，元素会被查到迭代器所指向的元素之前。</li>\r\n</ul></li>\r\n</ul>\r\n<p><strong>插入迭代器操作</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 22%\">\r\n<col style=\"width: 77%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>it=t</code></td>\r\n<td>在<code>it</code>指定的当前位置插入值<code>t</code>。假定<code>c</code>是<code>it</code>绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用<code>c.push_back(t)</code>、<code>c.push_front(t)</code>、<code>c.insert(t, p)</code>，其中<code>p</code>是传递给<code>inserter</code>的迭代器位置</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>*it, ++it, it++</code></td>\r\n<td>这些操作虽然存在，但不会对<code>it</code>做任何事情，每个操作都返回<code>it</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"iostream迭代器\">iostream迭代器</h3>\r\n<ul>\r\n<li>迭代器可与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。</li>\r\n<li>通过使用流迭代器，我们可以用泛型算法从流对象中读取数据以及向其写入数据。</li>\r\n</ul>\r\n<p><strong>istream_iterator的操作</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 32%\">\r\n<col style=\"width: 67%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>istream_iterator&lt;T&gt; in(is);</code></td>\r\n<td><code>in</code>从输入流<code>is</code>读取类型为<code>T</code>的值</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>istream_iterator&lt;T&gt; end;</code></td>\r\n<td>读取类型是<code>T</code>的值的<code>istream_iterator</code>迭代器，表示尾后位置</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>in1 == in2</code></td>\r\n<td><code>in1</code>和<code>in2</code>必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同的输入，则两者相等。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>in1 != in2</code></td>\r\n<td>类似上条</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>*in</code></td>\r\n<td>返回从流中读取的值</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>in-&gt;mem</code></td>\r\n<td>与<code>*(in).mem</code>含义相同</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>++in, in++</code></td>\r\n<td>使用元素类型所定义的<code>&gt;&gt;</code>运算符从流中读取下一个值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>ostream_iterator的操作</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 35%\">\r\n<col style=\"width: 64%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>ostream_iterator&lt;T&gt; out(os);</code></td>\r\n<td><code>out</code>将类型为<code>T</code>的值写到输出流<code>os</code>中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>ostream_iterator&lt;T&gt; out(os, d);</code></td>\r\n<td><code>out</code>将类型为<code>T</code>的值写到输出流<code>os</code>中，每个值后面都输出一个<code>d</code>。<code>d</code>指向一个空字符结尾的字符数组。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>out = val</code></td>\r\n<td>用<code>&lt;&lt;</code>运算符将<code>val</code>写入到<code>out</code>所绑定的<code>ostream</code>中。<code>val</code>的类型必须和<code>out</code>可写的类型兼容。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>*out, ++out, out++</code></td>\r\n<td>这些运算符是存在的，但不对<code>out</code>做任何事情。每个运算符都返回<code>out</code>。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"反向迭代器\">反向迭代器</h3>\r\n<ul>\r\n<li>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。</li>\r\n<li>对于反向迭代器，递增和递减的操作含义会颠倒。</li>\r\n<li>实现向后遍历，配合<code>rbegin</code>和<code>rend</code>。</li>\r\n</ul>\r\n<h2 id=\"泛型算法结构\">泛型算法结构</h2>\r\n<h3 id=\"类迭代器\">5类迭代器</h3>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 12%\">\r\n<col style=\"width: 32%\">\r\n<col style=\"width: 54%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>迭代器类别</th>\r\n<th>解释</th>\r\n<th>支持的操作</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>输入迭代器</td>\r\n<td>只读，不写；单遍扫描，只能递增</td>\r\n<td><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>输出迭代器</td>\r\n<td>只写，不读；单遍扫描，只能递增</td>\r\n<td><code>++</code>,<code>*</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>前向迭代器</td>\r\n<td>可读写；多遍扫描，只能递增</td>\r\n<td><code>==</code>,<code>!=</code>,<code>++</code>,<code>*</code>,<code>-&gt;</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>双向迭代器</td>\r\n<td>可读写；多遍扫描，可递增递减</td>\r\n<td><code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>,<code>*</code>,<code>-&gt;</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>随机访问迭代器</td>\r\n<td>可读写，多遍扫描，支持全部迭代器运算</td>\r\n<td><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>,<code>++</code>,<code>--</code>,<code>+</code>,<code>+=</code>,<code>-</code>,<code>-=</code>,<code>*</code>,<code>-&gt;</code>,<code>iter[n]</code>==<code>*(iter[n])</code></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"算法的形参模式\">算法的形参模式</h3>\r\n<ul>\r\n<li><code>alg(beg, end, other args);</code></li>\r\n<li><code>alg(beg, end, dest, other args);</code></li>\r\n<li><code>alg(beg, end, beg2, other args);</code></li>\r\n<li><code>alg(beg, end, beg2, end2, other args);</code></li>\r\n</ul>\r\n<p>其中，<code>alg</code>是算法名称，<code>beg</code>和<code>end</code>表示算法所操作的输入范围。<code>dest</code>、<code>beg2</code>、<code>end2</code>都是迭代器参数，是否使用要依赖于执行的操作。</p>\r\n<h3 id=\"算法命名规范\">算法命名规范</h3>\r\n<ul>\r\n<li>一些算法使用重载形式传递一个谓词。</li>\r\n<li>接受一个元素值的算法通常有一个<strong>不同名</strong>的版本：加<code>_if</code>，接受一个谓词代替元素值。</li>\r\n<li>区分拷贝元素的版本和不拷贝的版本：拷贝版本通常加<code>_copy</code>。</li>\r\n</ul>\r\n<h2 id=\"特定容器算法\">特定容器算法</h2>\r\n<ul>\r\n<li>对于<code>list</code>和<code>forward_list</code>，优先使用成员函数版本的算法而不是通用算法。</li>\r\n</ul>\r\n<p><strong>list和forward_list成员函数版本的算法</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 27%\">\r\n<col style=\"width: 72%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>lst.merge(lst2)</code></td>\r\n<td>将来自<code>lst2</code>的元素合并入<code>lst</code>，二者都必须是有序的，元素将从<code>lst2</code>中删除。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>lst.merge(lst2, comp)</code></td>\r\n<td>同上，给定比较操作。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>lst.remove(val)</code></td>\r\n<td>调用<code>erase</code>删除掉与给定值相等(==)的每个元素</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>lst.remove_if(pred)</code></td>\r\n<td>调用<code>erase</code>删除掉令一元谓词为真的每个元素</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>lst.reverse()</code></td>\r\n<td>反转<code>lst</code>中元素的顺序</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>lst.sort()</code></td>\r\n<td>使用<code>&lt;</code>排序元素</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>lst.sort(comp)</code></td>\r\n<td>使用给定比较操作排序元素</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>lst.unique()</code></td>\r\n<td>调用<code>erase</code>删除同一个值的连续拷贝。使用<code>==</code>。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>lst.unique(pred)</code></td>\r\n<td>调用<code>erase</code>删除同一个值的连续拷贝。使用给定的二元谓词。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>上面的操作都返回<code>void</code></li>\r\n</ul>\r\n<p><strong>list和forward_list的splice成员函数版本的参数</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 22%\">\r\n<col style=\"width: 77%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>参数</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>(p, lst2)</code></td>\r\n<td><code>p</code>是一个指向<code>lst</code>中元素的迭代器，或者一个指向<code>flst</code>首前位置的迭代器。函数将<code>lst2</code>中的所有元素移动到<code>lst</code>中<code>p</code>之前的位置或是<code>flst</code>中<code>p</code>之后的位置。将元素从<code>lst2</code>中删除。<code>lst2</code>的类型必须和<code>lst</code>相同，而且不能是同一个链表。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>(p, lst2, p2)</code></td>\r\n<td>同上，<code>p2</code>是一个指向<code>lst2</code>中位置的有效的迭代器，将<code>p2</code>指向的元素移动到<code>lst</code>中，或将<code>p2</code>之后的元素移动到<code>flst</code>中。<code>lst2</code>可以是于<code>lst</code>或<code>flst</code>相同的链表。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>(p, lst2, b, e)</code></td>\r\n<td><code>b</code>和<code>e</code>表示<code>lst2</code>中的合法范围。将给定范围中的元素从<code>lst2</code>移动到<code>lst</code>或<code>first</code>中。<code>lst2</code>与<code>lst</code>可以使相同的链表，但<code>p</code>不能指向给定范围中的元素。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>使用<code>lst.splice(args)</code>或<code>flst.splice_after(args)</code></li>\r\n</ul>\r\n"},{"title":"cppprimer第十二章","url":"/posts/ba565e9d/","content":"<span id=\"more\"></span>\r\n<h1 id=\"第十二章-动态内存\">第十二章 动态内存</h1>\r\n<ul>\r\n<li>对象的生命周期：\r\n<ul>\r\n<li>全局对象在程序启动时分配，结束时销毁。</li>\r\n<li>局部对象在进入程序块时创建，离开块时销毁。</li>\r\n<li>局部<code>static</code>对象在第一次使用前分配，在程序结束时销毁。</li>\r\n<li>动态分配对象：只能显式地被释放。</li>\r\n</ul></li>\r\n<li>对象的内存位置：\r\n<ul>\r\n<li><strong>静态内存</strong>用来保存局部<code>static</code>对象、类<code>static</code>对象、定义在任何函数之外的变量。</li>\r\n<li><strong>栈内存</strong>用来保存定义在函数内的非<code>static</code>对象。</li>\r\n<li><strong>堆内存</strong>，又称自由空间，用来存储<strong>动态分配</strong>的对象。</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"动态内存与智能指针\">动态内存与智能指针</h2>\r\n<ul>\r\n<li>动态内存管理：\r\n<ul>\r\n<li><code>new</code>：在动态内存中为对象分配空间并返回一个指向该对象的指针。</li>\r\n<li><code>delete</code>：接受一个动态对象的指针(new分配或空指针)，销毁该对象，并释放与之关联的内存。</li>\r\n</ul></li>\r\n<li>智能指针：\r\n<ul>\r\n<li>管理动态对象。</li>\r\n<li>行为类似常规指针。</li>\r\n<li>负责自动释放所指向的对象。</li>\r\n<li>智能指针也是模板。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"shared_ptr类\">shared_ptr类</h3>\r\n<p><strong>shared_ptr和unique_ptr都支持的操作</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 38%\">\r\n<col style=\"width: 61%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>shared_ptr&lt;T&gt; sp</code>\r\n<code>unique_ptr&lt;T&gt; up</code></td>\r\n<td>空智能指针，可以指向类型是<code>T</code>的对象</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>p.get()</code></td>\r\n<td>返回<code>p</code>中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>shared_ptr独有的操作</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 26%\">\r\n<col style=\"width: 73%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>make_shared&lt;T&gt;(args)</code></td>\r\n<td>返回一个<code>shared_ptr</code>，指向一个动态分配的类型为<code>T</code>的对象。使用<code>args</code>初始化此对象。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>shared_ptr&lt;T&gt;p(q)</code></td>\r\n<td><code>p</code>是<code>shared_ptr q</code>的拷贝；此操作会<strong>递增</strong><code>q</code>中的计数器。<code>q</code>中的指针必须能转换为<code>T*</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>p = q</code></td>\r\n<td><code>p</code>和<code>q</code>都是<code>shared_ptr</code>，所保存的指针必须能互相转换。此操作会<strong>递减</strong><code>p</code>的引用计数，<strong>递增</strong><code>q</code>的引用计数；若<code>p</code>的引用计数变为0，则将其管理的原内存释放。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>p.unique()</code></td>\r\n<td>若<code>p.use_count()</code>是1，返回<code>true</code>；否则返回<code>false</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>p.use_count()</code></td>\r\n<td>返回与<code>p</code>共享对象的智能指针数量；可能很慢，主要用于调试。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><strong>使用动态内存的三种原因</strong>：\r\n<ul>\r\n<li>程序不知道自己需要使用多少对象（比如容器类）。</li>\r\n<li>程序不知道所需要对象的准确类型。</li>\r\n<li>程序需要在多个对象间共享数据。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"直接管理内存\">直接管理内存</h3>\r\n<ul>\r\n<li>用<code>new</code>动态分配和初始化对象。\r\n<ul>\r\n<li><code>new</code>无法为分配的对象命名（因为自由空间分配的内存是无名的），因此是返回一个指向该对象的指针。</li>\r\n<li><code>int *pi = new int([123]);</code> 不写123默认值初始化。</li>\r\n<li><code>vector&lt;int&gt; *pv = new vector&lt;int&gt;{1, 2, 3};</code></li>\r\n<li>一旦内存耗尽，会抛出类型是<code>bad_alloc</code>的异常。</li>\r\n</ul></li>\r\n<li>用<code>delete</code>将动态内存归还给系统。\r\n<ul>\r\n<li>接受一个指针，指向要释放的对象。</li>\r\n<li><code>delete</code>后的指针称为空悬指针（dangling pointer）。</li>\r\n</ul></li>\r\n<li>使用<code>new</code>和<code>delete</code>管理动态内存存在三个常见问题：\r\n<ul>\r\n<li>1.忘记<code>delete</code>内存。</li>\r\n<li>2.使用已经释放掉的对象。</li>\r\n<li>3.同一块内存释放两次。</li>\r\n</ul></li>\r\n<li>坚持只使用智能指针可以避免上述所有问题。</li>\r\n</ul>\r\n<h3 id=\"shared_ptr和new结合使用\">shared_ptr和new结合使用</h3>\r\n<p><strong>定义和改变shared_ptr的其他方法</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 28%\">\r\n<col style=\"width: 71%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>shared_ptr&lt;T&gt; p(q)</code></td>\r\n<td><code>p</code>管理内置指针<code>q</code>所指向的对象；<code>q</code>必须指向<code>new</code>分配的内存，且能够转换为<code>T*</code>类型</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>shared_ptr&lt;T&gt; p(u)</code></td>\r\n<td><code>p</code>从<code>unique_ptr u</code>那里接管了对象的所有权；将<code>u</code>置为空</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>shared_ptr&lt;T&gt; p(q, d)</code></td>\r\n<td><code>p</code>接管了内置指针<code>q</code>所指向的对象的所有权。<code>q</code>必须能转换为<code>T*</code>类型。<code>p</code>将使用可调用对象<code>d</code>来代替<code>delete</code>。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>shared_ptr&lt;T&gt; p(p2, d)</code></td>\r\n<td><code>p</code>是<code>shared_ptr p2</code>的拷贝，唯一的区别是<code>p</code>将可调用对象<code>d</code>来代替<code>delete</code>。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>p.reset()</code></td>\r\n<td>若<code>p</code>是唯一指向其对象的<code>shared_ptr</code>，<code>reset</code>会释放此对象。若传递了可选的参数内置指针<code>q</code>，会令<code>p</code>指向<code>q</code>，否则会将<code>p</code>置空。若还传递了参数<code>d</code>，则会调用<code>d</code>而不是<code>delete</code>来释放<code>q</code>。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>p.reset(q)</code></td>\r\n<td>同上</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>p.reset(q, d)</code></td>\r\n<td>同上</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"智能指针和异常\">智能指针和异常</h3>\r\n<ul>\r\n<li>如果使用智能指针，即使程序块由于异常过早结束，智能指针类也能确保在内存不需要的时候将其释放。</li>\r\n<li><strong>智能指针陷阱</strong>：\r\n<ul>\r\n<li>不用相同的内置指针初始化（或<code>reset</code>）多个智能指针</li>\r\n<li>不<code>delete get()</code>返回的指针。</li>\r\n<li>如果你使用<code>get()</code>返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。</li>\r\n<li>如果你使用智能指针管理的资源不是<code>new</code>分配的内存，记住传递给它一个删除器。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"unique_ptr\">unique_ptr</h3>\r\n<ul>\r\n<li>某一个时刻只能有一个<code>unique_ptr</code>指向一个给定的对象。</li>\r\n<li>不支持拷贝或者赋值操作。但可以：<code>p1.reset(p2.release();</code></li>\r\n<li>向后兼容：<code>auto_ptr</code>：老版本，具有<code>unique_ptr</code>的部分特性。特别是，不能在容器中保存<code>auto_ptr</code>，也不能从函数返回<code>auto_ptr</code>。</li>\r\n</ul>\r\n<p><strong>unique_ptr操作</strong>:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 27%\">\r\n<col style=\"width: 72%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>unique_ptr&lt;T&gt; u1</code></td>\r\n<td>空<code>unique_ptr</code>，可以指向类型是<code>T</code>的对象。<code>u1</code>会使用<code>delete</code>来是释放它的指针。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>unique_ptr&lt;T, D&gt; u2</code></td>\r\n<td><code>u2</code>会使用一个类型为<code>D</code>的可调用对象来释放它的指针。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>unique_ptr&lt;T, D&gt; u(d)</code></td>\r\n<td>空<code>unique_ptr</code>，指向类型为<code>T</code>的对象，用类型为<code>D</code>的对象<code>d</code>代替<code>delete</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>u = nullptr</code></td>\r\n<td>释放<code>u</code>指向的对象，将<code>u</code>置为空。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>u.release()</code></td>\r\n<td><code>u</code>放弃对指针的控制权，返回指针，并将<code>u</code>置空。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>u.reset()</code></td>\r\n<td>释放<code>u</code>指向的对象</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>u.reset(q)</code></td>\r\n<td>令<code>u</code>指向<code>q</code>指向的对象</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>u.reset(nullptr)</code></td>\r\n<td>将<code>u</code>置空</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"weak_ptr\">weak_ptr</h3>\r\n<ul>\r\n<li><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针。</li>\r\n<li>指向一个由<code>shared_ptr</code>管理的对象，不改变<code>shared_ptr</code>的引用计数。</li>\r\n<li>一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，不管有没有<code>weak_ptr</code>指向该对象。</li>\r\n</ul>\r\n<p><strong>weak_ptr操作</strong>:</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 24%\">\r\n<col style=\"width: 75%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>weak_ptr&lt;T&gt; w</code></td>\r\n<td>空<code>weak_ptr</code>可以指向类型为<code>T</code>的对象</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>\r\n<td>与<code>shared_ptr</code>指向相同对象的<code>weak_ptr</code>。<code>T</code>必须能转换为<code>sp</code>指向的类型。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>w = p</code></td>\r\n<td><code>p</code>可以是<code>shared_ptr</code>或一个<code>weak_ptr</code>。赋值后<code>w</code>和<code>p</code>共享对象。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>w.reset()</code></td>\r\n<td>将<code>w</code>置为空。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>w.use_count()</code></td>\r\n<td>与<code>w</code>共享对象的<code>shared_ptr</code>的数量。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>w.expired()</code></td>\r\n<td>若<code>w.use_count()</code>为0，返回<code>true</code>，否则返回<code>false</code></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>w.lock()</code></td>\r\n<td>如果<code>expired</code>为<code>true</code>，则返回一个空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code>。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"动态数组\">动态数组</h2>\r\n<h3 id=\"new和数组\">new和数组</h3>\r\n<ul>\r\n<li><code>new</code>一个动态数组：\r\n<ul>\r\n<li>类型名之后加一对方括号，指明分配的对象数目（必须是整型，不必是常量）。</li>\r\n<li>返回<strong>指向第一个对象的指针</strong>。</li>\r\n<li><code>int *p = new int[size];</code></li>\r\n</ul></li>\r\n<li><code>delete</code>一个动态数组：\r\n<ul>\r\n<li><code>delete [] p;</code></li>\r\n</ul></li>\r\n<li><code>unique_ptr</code>和数组：\r\n<ul>\r\n<li>指向数组的<code>unique_ptr</code>不支持成员访问运算符（点和箭头）。</li>\r\n</ul></li>\r\n</ul>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 26%\">\r\n<col style=\"width: 73%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>unique_ptr&lt;T[]&gt; u</code></td>\r\n<td><code>u</code>可以指向一个动态分配的数组，整数元素类型为<code>T</code></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>unique_ptr&lt;T[]&gt; u(p)</code></td>\r\n<td><code>u</code>指向内置指针<code>p</code>所指向的动态分配的数组。<code>p</code>必须能转换为类型<code>T*</code>。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>u[i]</code></td>\r\n<td>返回<code>u</code>拥有的数组中位置<code>i</code>处的对象。<code>u</code>必须指向一个数组。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"allocator类\">allocator类</h3>\r\n<ul>\r\n<li>标准库<code>allocator</code>类定义在头文件<code>memory</code>中，帮助我们将内存分配和对象构造分离开。</li>\r\n<li>分配的是原始的、未构造的内存。</li>\r\n<li><code>allocator</code>是一个模板。</li>\r\n<li><code>allocator&lt;string&gt; alloc;</code></li>\r\n</ul>\r\n<p><strong>标准库allocator类及其算法</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 26%\">\r\n<col style=\"width: 73%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>allocator&lt;T&gt; a</code></td>\r\n<td>定义了一个名为<code>a</code>的<code>allocator</code>对象，它可以为类型为<code>T</code>的对象分配内存</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>a.allocate(n)</code></td>\r\n<td>分配一段原始的、未构造的内存，保存<code>n</code>个类型为<code>T</code>的对象。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>a.deallocate(p, n)</code></td>\r\n<td>释放从<code>T*</code>指针<code>p</code>中地址开始的内存，这块内存保存了<code>n</code>个类型为<code>T</code>的对象；<code>p</code>必须是一个先前由<code>allocate</code>返回的指针。且<code>n</code>必须是<code>p</code>创建时所要求的大小。在调用<code>deallocate</code>之前，用户必须对每个在这块内存中创建的对象调用<code>destroy</code>。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>a.construct(p, args)</code></td>\r\n<td><code>p</code>必须是一个类型是<code>T*</code>的指针，指向一块原始内存；<code>args</code>被传递给类型为<code>T</code>的构造函数，用来在<code>p</code>指向的内存中构造一个对象。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>a.destroy(p)</code></td>\r\n<td><code>p</code>为<code>T*</code>类型的指针，此算法对<code>p</code>指向的对象执行析构函数。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><strong>allocator伴随算法</strong>：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 34%\">\r\n<col style=\"width: 65%\">\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>操作</th>\r\n<th>解释</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td><code>uninitialized_copy(b, e, b2)</code></td>\r\n<td>从迭代器<code>b</code>和<code>e</code>给定的输入范围中拷贝元素到迭代器<code>b2</code>指定的未构造的原始内存中。<code>b2</code>指向的内存必须足够大，能够容纳输入序列中元素的拷贝。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>uninitialized_copy_n(b, n, b2)</code></td>\r\n<td>从迭代器<code>b</code>指向的元素开始，拷贝<code>n</code>个元素到<code>b2</code>开始的内存中。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td><code>uninitialized_fill(b, e, t)</code></td>\r\n<td>在迭代器<code>b</code>和<code>e</code>执行的原始内存范围中创建对象，对象的值均为<code>t</code>的拷贝。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td><code>uninitialized_fill_n(b, n, t)</code></td>\r\n<td>从迭代器<code>b</code>指向的内存地址开始创建<code>n</code>个对象。<code>b</code>必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>定义在头文件<code>memory</code>中。</li>\r\n<li>在给定目的位置创建元素，而不是由系统分配内存给他们。</li>\r\n</ul>\r\n"},{"url":"/posts/0/","content":"<p>一元运算符运算顺序从右向左。</p>\r\n"},{"title":"博客备忘录","url":"/posts/ed1ccd58/","content":"<p>记录博客一些操作和语法。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"note-标签\">Note 标签</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">{% note %}</span><br><span class=\"line\">default 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note primary %}</span><br><span class=\"line\">primary 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note success %}</span><br><span class=\"line\">success 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note info %}</span><br><span class=\"line\">info 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note warning %}</span><br><span class=\"line\">warning 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note danger %}</span><br><span class=\"line\">danger 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br></pre></td></tr></table></figure>\r\n<p>效果：</p>\r\n<div class=\"note \"><p>default 提示块标签</p>\r\n</div>\r\n<div class=\"note primary\"><p>primary 提示块标签</p>\r\n</div>\r\n<div class=\"note success\"><p>success 提示块标签</p>\r\n</div>\r\n<div class=\"note info\"><p>info 提示块标签</p>\r\n</div>\r\n<div class=\"note warning\"><p>warning 提示块标签</p>\r\n</div>\r\n<div class=\"note danger\"><p>danger 提示块标签</p>\r\n</div>\r\n","categories":["杂项"],"tags":["博客","test"]},{"title":"cppprimer第七章","url":"/posts/76c57c5e/","content":"<p><strong>第7章 类</strong></p>\r\n<span id=\"more\"></span>\r\n<p><strong>7.1 定义抽象数据类型</strong></p>\r\n<p><strong>7.1.2 定义改进的sales_data类</strong></p>\r\n<p><strong>引入 this</strong></p>\r\n<p>成员函数通过一个名为 this\r\n的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用\r\n<code>total.isbn ()</code></p>\r\n<p>则编译器负责把 total 的地址传递给 isbn 的隐式形参 this，等价于:\r\n<code>Sales_data::isbn(&amp;total)</code></p>\r\n<p>在成员函数内部，可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符，因为\r\nthis 所指的正是这个对象。任何对类成员的直接访问都被看作 this\r\n的隐式引用：当 isbn 使用 bookNo 时，它隐式地使用 this\r\n指向的成员，就像我们书写了 <code>this-&gt;bookNo</code>一样。</p>\r\n<p>this 形参是隐式定义的。任何自定义名为 this\r\n的参数或变量的行为都是非法的。我们可以在成员函数体内部使用\r\nthis，尽管没有必要:\r\n<code>std::string isbn () const {return this-&gt;bookNo;}</code></p>\r\n<p>因为 this 的目的总是指向这个对象，所以 this\r\n是一个常量指针，不允许改变 this 中保存的地址。</p>\r\n<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数，const\r\n在参数列表后，this\r\n此时指向常量指针，常量成员函数不能改变调用它的对象的内容：<code>string isbn() const {return bookNo;}</code></p>\r\n<p>成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>\r\n<p>定义在类内部的函数是隐式的 inline 函数。</p>\r\n<p>定义在类外部的函数要加上类作用域。</p>\r\n<p><strong>定义一个返回 this 对象的函数</strong></p>\r\n<p>函数combine的设计初衷类似于复合赋值运算符+=：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Sales_data&amp; <span class=\"title\">Sales_data::combine</span> <span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class=\"line\">\tunits_sold += rhs.units_sold; <span class=\"comment\">// 把rhs的成员加到this对象的成员上</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; <span class=\"comment\">// 返回调用该函数的对象</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p>当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧运算对象当成左值返回，为了与它保持一致，combine函数必须返回引用类型。</p>\r\n<p><strong>7.1.3 定义类相关的非成员函数</strong></p>\r\n<p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span> <span class=\"params\">(ostream &amp;os, <span class=\"type\">const</span> Sales_data &amp;item)</span> </span>{ <span class=\"comment\">// IO类属于不能被拷贝的类型，只能通过引用传递</span></span><br><span class=\"line\">\tos &lt;&lt; item.<span class=\"built_in\">isbn</span>() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; item.<span class=\"built_in\">units_sold</span>() &lt;&lt; <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t   &lt;&lt; item.<span class=\"built_in\">revenue</span>() &lt;&lt;<span class=\"string\">\" \"</span> &lt;&lt; item.avg _price();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p><strong>7.1.4 构造函数</strong></p>\r\n<p>构造函数用来初始化类对象的数据成员。当类的对象被创建时，就会执行构造函数。</p>\r\n<p>构造函数没有返回类型。</p>\r\n<p>构造函数可以重载。</p>\r\n<p>构造函数不可以声明为 const。当创建一个 const\r\n对象时，直到构造函数完成其初始化过程，对象才真的取得其常量属性。</p>\r\n<p>如果类没有任何构造函数，则编译器自己会创建默认构造函数：</p>\r\n<ul>\r\n<li>如果存在类内的初始值，用它来初始化成员。</li>\r\n<li>否则，默认初始化该成员。</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sales_data</span> {</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> istream &amp;<span class=\"title\">read</span><span class=\"params\">(istream &amp;is, Sales_data &amp;item)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os, <span class=\"type\">const</span> Sales_data &amp;item)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> Sales_data <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;lhs, <span class=\"type\">const</span> Sales_data &amp;rhs)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> string &amp;s) : <span class=\"built_in\">bookNo</span>(s) {}</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> string &amp;s, <span class=\"type\">unsigned</span> n, <span class=\"type\">double</span> p) : <span class=\"built_in\">bookNo</span>(s), <span class=\"built_in\">units_sold</span>(n), <span class=\"built_in\">revenue</span>(n * p) {}</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(istream &amp;is) {<span class=\"built_in\">read</span>(is, *<span class=\"keyword\">this</span>);}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">isbn</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{<span class=\"keyword\">return</span> bookNo;};</span><br><span class=\"line\">    <span class=\"function\">Sales_data &amp;<span class=\"title\">combine</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string bookNo;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> units_sold = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">double</span> revenue = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Sales_data &amp;<span class=\"title\">Sales_data::combine</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class=\"line\">    units_sold += rhs.units_sold;</span><br><span class=\"line\">    revenue += rhs.revenue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">istream &amp;<span class=\"title\">read</span><span class=\"params\">(istream &amp;is, Sales_data &amp;item)</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">double</span> price = <span class=\"number\">0</span>;</span><br><span class=\"line\">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class=\"line\">    item.revenue = price * item.units_sold;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> is;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os, <span class=\"type\">const</span> Sales_data &amp;item)</span> </span>{</span><br><span class=\"line\">    os &lt;&lt; item.<span class=\"built_in\">isbn</span>() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; item.units_sold &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; item.revenue;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Sales_data <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">const</span> Sales_data &amp;lhs, <span class=\"type\">const</span> Sales_data &amp;rhs)</span> </span>{</span><br><span class=\"line\">    Sales_data sum = lhs;</span><br><span class=\"line\">    sum.<span class=\"built_in\">combine</span>(rhs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p><strong>= default 的含义</strong></p>\r\n<p>默认构造函数，这里没有参数的原因是类内有初始值。如果没有，需要用构造函数初始值列表。</p>\r\n<p><strong>构造函数初始值列表</strong></p>\r\n<p>冒号和冒号和花括号之间的代码。</p>\r\n<p><strong>在类的外部定义构造函数</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sales_data::<span class=\"built_in\">Sales_data</span>(istream &amp;is) {</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(is, *<span class=\"keyword\">this</span>); <span class=\"comment\">// read函数的作用是从is中读取一条交易信息然后存入this对象中</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p><strong>7.1.5 拷贝、赋值和折构</strong></p>\r\n<p>对于拷贝、赋值和销毁对象等操作，类都通过相应的成员函数实现其功能，如果不主动定义这些操作，编译器就合成默认的版本。</p>\r\n<p>对于某些类来说，无法使用默认合成的版本，比如管理动态内存的类就不能。</p>\r\n<p><strong>7.2 访问控制与封装</strong></p>\r\n<p>访问说明符：class, public。可以在类内出现多次。</p>\r\n<p>class 和 struct\r\n的<strong>唯一一点区别</strong>就是默认访问权限不同。</p>\r\n<p><strong>当希望类的所有成员是 public 时，用 struct。</strong></p>\r\n<p><strong>7.2.1 友元</strong></p>\r\n<p>类可以允许其他类或函数访问它的非公有成员，方法就是令其他函数或类成为它的<strong>友元</strong>，加一条关键字\r\nfriend 开头的函数声明语句即可。</p>\r\n<p><strong>友元声明只能出现在类的内部</strong>，最好在类的开始或结束位置集中声明友元。</p>\r\n<p><strong>7.3 类的其他特性</strong></p>\r\n<p><strong>7.3.1 类成员再探</strong></p>\r\n<p><strong>定义类型成员</strong></p>\r\n<p>类可以自定义某种类型在类内的别名。类型成员一样有访问限制。</p>\r\n<p><strong>类型成员必须先定义后使用</strong>，因此类型成员应该出现在类开始的地方。</p>\r\n<p><strong>默认构造函数</strong></p>\r\n<p>当定义了构造函数，不会再有默认构造函数，如果需要必须显式声明：<code>Student() = default;</code></p>\r\n<p><strong>类内初始值</strong></p>\r\n<p>成员变量可以在类内定义的时候直接初始化。</p>\r\n<p>此时构造函数的初始化列表可以不包含该成员变量，隐式使用其类内初始值。</p>\r\n<p>类内初始值必须使用等号或花括号初始化。</p>\r\n<p><strong>内联成员函数</strong></p>\r\n<p><strong>4</strong>种方式使成员成为内联函数：</p>\r\n<ol type=\"1\">\r\n<li>在类内定义函数，为隐式内联。</li>\r\n<li>在类内用关键字 inline 显式声明成员函数。</li>\r\n<li>在类外用关键字 inline 定义成员函数。</li>\r\n<li>同时在类内类外用 inline 修饰。</li>\r\n</ol>\r\n<p>inline 成员函数应该与类定义在同一个头文件中。</p>\r\n<p><strong>可变数据成员</strong></p>\r\n<p>const 成员函数不能修改成员变量。</p>\r\n<p>但是用 <strong>mutable</strong>\r\n将成员修饰为可变数据成员，就可以修改了。</p>\r\n<p><strong>7.3.2 返回 *this 的成员函数</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> screen &amp;<span class=\"title\">Screen::move</span><span class=\"params\">(pos r, pos c)</span> </span>{</span><br><span class=\"line\">    pos row = r * width; <span class=\"comment\">// 计算行的位置</span></span><br><span class=\"line\">    cursor = row + C; <span class=\"comment\">// 在行内将光标移动到指定的列</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>; <span class=\"comment\">// 以左值的形式返回对象</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> screen &amp;<span class=\"title\">screen::set</span><span class=\"params\">(<span class=\"type\">char</span> c)</span> </span>{</span><br><span class=\"line\">    contents [cursor] = C; <span class=\"comment\">// 设置当前光标所在位置的新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;          <span class=\"comment\">// 将this对象作为左值返回</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">myscreen.<span class=\"built_in\">move</span>(<span class=\"number\">4</span>,<span class=\"number\">0</span>).<span class=\"built_in\">set</span> (<span class=\"string\">'#’); // 把光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br></pre></td></tr></table></figure>\r\n<p>可以<strong>定义</strong>返回类型为类对象的引用的函数。如果定义的返回类型不是引用，返回的是\r\n*this 的副本。</p>\r\n<p>const 函数如果以引用的形式返回 this，返回类型就是一个常量引用。</p>\r\n<p><strong>7.3.3 类类型</strong></p>\r\n<p>类名不同，类不同。</p>\r\n<p>一个类的成员类型不能是它自己，但是一旦一个类的名字出现后，它就被认为是被声明过了，所以类允许包含指向它自身类型的引用或指针。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Link_screen</span> {</span><br><span class=\"line\">\tscreen window;</span><br><span class=\"line\">\tLink_screen *next;</span><br><span class=\"line\">\tLink_screen *prev;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\r\n<p>练习：定义一对类 X 和 Y，其中 X 包含一个指向 Y 的指针，而Y\r\n包含一个类型为 X 的对象。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">X</span>{</span><br><span class=\"line\">\tY* y = <span class=\"literal\">nullptr</span>;\t</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Y</span>{</span><br><span class=\"line\">\tX x;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\r\n<p><strong>7.3.4 友元再探</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">screen</span> {</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Window_mgr</span>;                    <span class=\"comment\">// 其他类作为友元</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Window_mgr::clear</span><span class=\"params\">(screenIndex)</span></span>; <span class=\"comment\">// 其他类的成员函数作为友元</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\r\n<p>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系，顺序：</p>\r\n<ul>\r\n<li>定义Window mgr类，其中声明clear函数，但是不能定义它。</li>\r\n<li>在clear使用Screen 的成员之前必须先声明Screen。</li>\r\n<li>定义Screen，包括对于clear的友元声明。</li>\r\n<li>最后定义clear，此时它才可以使用screen的成员。</li>\r\n</ul>\r\n<p>如果一个类指定了友元类。则友元类的成员函数可以访问此类的所有成员。</p>\r\n<p>友元关系不具有传递性。</p>\r\n<p>重载函数名字相同，但是是不同的函数。如果想把一组重载函数声明为类的友元，需要对每一个分别声明。</p>\r\n<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。<br>\r\n甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的:</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">X</span> {</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>{<span class=\"comment\">/*友元函数可以定义在类的内部*/</span>}</span><br><span class=\"line\">    <span class=\"built_in\">X</span>() {<span class=\"built_in\">f</span>();} <span class=\"comment\">//错误:f还没有被声明</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">h</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">X::g</span><span class=\"params\">()</span> </span>{<span class=\"keyword\">return</span> <span class=\"built_in\">f</span>();}<span class=\"comment\">//错误:f还没有被声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>; <span class=\"comment\">//声明那个定义在X中的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">X::h</span><span class=\"params\">()</span> </span>{<span class=\"keyword\">return</span> <span class=\"built_in\">f</span>();}<span class=\"comment\">//正确:现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure>\r\n<p>友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p>\r\n<p><strong>7.4 类的作用域</strong></p>\r\n<p>类名表示了作用域，一个函数只需要在函数名前授权一次作用域，其他变量就知道这是在类中，无需重复授权。</p>\r\n<p>当类的成员函数的返回类型也是类的成员时，在定义它时要指明类\r\n<code>Student::age Student::Getage() {}</code></p>\r\n<p><strong>7.4.1 名字查找与类的作用域</strong></p>\r\n<p><strong>普通程序名字查找的过程</strong></p>\r\n<ol type=\"1\">\r\n<li>首先在名字所在的块中寻找声明语句</li>\r\n<li>如果没找到，继续查找外层作用域</li>\r\n<li>如果最终还是没找到，报错</li>\r\n</ol>\r\n<p><strong>类的定义过程</strong></p>\r\n<ol type=\"1\">\r\n<li>编译成员的声明。</li>\r\n<li>直到全部类可见后才编译成员函数体。</li>\r\n</ol>\r\n<p>在类内定义的类型名要放在类的开始，放在后面其他成员是看不见的。</p>\r\n<p>类型名如果在类外已经定义过，不能在类内重定义。</p>\r\n<p><strong>7.5 构造函数再探</strong></p>\r\n<p><strong>7.5.1 构造函数初始值列表</strong></p>\r\n<p>使用初始值列表对类的成员初始化才是真正的初始化，在构造函数的函数体内赋值并不是初始化：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Sales_data::<span class=\"built_in\">Sales_data</span>(<span class=\"type\">const</span> string &amp;s, <span class=\"type\">unsigned</span> cnt, <span class=\"type\">double</span> price) {</span><br><span class=\"line\">    bookNo = s;</span><br><span class=\"line\">    units_sold = cnt;</span><br><span class=\"line\">    revenue = cnt * price;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<p>建议构造函数使用初始值。</p>\r\n<p>如果成员是 <strong>const\r\n或者是引用的话，必须初始化</strong>。赋值是错误的。</p>\r\n<p>如果成员是类并且该类没有定义构造函数的话，必须初始化。</p>\r\n<p>使用初始值列表初始成员时，成员初始化的顺序是按照类定义出现的顺序初始化的。</p>\r\n<p><strong>默认实参和构造函数</strong></p>\r\n<p>如果一个构造函数为所有参数提供了默认实参，则<strong>它实际上相当于定义了默认构造函数</strong>。</p>\r\n<p>如果接受string 的构造函数和接受 istream&amp;\r\n的构造函数都使用默认实参，调用默认实参函数时不知道应该重载哪一个函数，非法。</p>\r\n<p><strong>7.5.2 委托构造函数</strong></p>\r\n<p><strong>委托构造函数</strong>通过其他构造函数来执行自己的初始化过程。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sales_data</span> {</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"comment\">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(std::string s, <span class=\"type\">unsigned</span> cnt, <span class=\"type\">double</span> price): <span class=\"built_in\">bookNo</span>(s) , <span class=\"built_in\">units_sold</span>(cnt), <span class=\"built_in\">revenue</span>(cnt * price) {}</span><br><span class=\"line\"><span class=\"comment\">//其余构造函数全都委托给另一个构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>() : <span class=\"built_in\">Sales_data</span>(<span class=\"string\">\"\"</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) {}</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(std: : string s) : <span class=\"built_in\">Sales_data</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>) {}</span><br><span class=\"line\">    <span class=\"built_in\">Sales_data</span>(std::istream &amp;is) : <span class=\"built_in\">Sales_data</span>() {<span class=\"built_in\">read</span>(is, *<span class=\"keyword\">this</span>);}</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\r\n<p><strong>7.5.4 隐式的类类型转换</strong></p>\r\n<p>如果构造函数只接受一个实参，则称作<strong>转换构造函数</strong>，它实际上定义了转换为此类类型的隐式转换机制。</p>\r\n<p><strong>一个实参的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</strong></p>\r\n<p><strong>只允许一步类型转换</strong></p>\r\n<p>在进行隐式转换时，编译器只会自动地执行一步类型转换。</p>\r\n<p>​ string null_book = \"9-999\"; item.combine(null_book); //conbine\r\n函数接受 Sales_data 类类型，但该类定义了一个接受 string\r\n参数的转换构造函数，所以这里会执行从 string\r\n到该类类型的隐式转换，是正确的。 item.combine(\"9-999\");\r\n//隐式地使用了两种转换规则，所以是错误的。\r\nitem.combine(string(\"9-999\")); //先显示地转换为 string，再隐式地转换为\r\nSales_data 类类型。是正确的。</p>\r\n<p><strong>explicit-抑制构造函数定义的隐式转换</strong></p>\r\n<p>将转换构造函数声明为 explicit 会阻止隐式转换。</p>\r\n<p>关键字 explicit\r\n只对一个实参的构造函数有效。因为需要多个实参的构造函数本来就不执行隐式转换。</p>\r\n<p>explicit 只在类内声明构造函数时使用，在类外定义时不加。类似 static\r\n成员函数</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">item.<span class=\"built_in\">combine</span> (null_book);<span class=\"comment\">//错误:string构造函数是explicit的</span></span><br><span class=\"line\">item. <span class=\"built_in\">combine</span> (cin);<span class=\"comment\">//错误: istream构造函数是explicit的</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>explicit 构造函数只能用于直接初始化</strong></p>\r\n<p>explicit 构造函数只能用于直接初始化，不能用于使用 \"=\"\r\n的拷贝初始化。理解：因为 “=”\r\n实际上是采用了拷贝赋值运算符，在传参时会进行隐式转换。</p>\r\n<p>理解：不加 explicit\r\n的转换构造函数，可以在赋值、传参、从函数返回等场合执行隐式转换，加了\r\nexplicit 后，就不能隐式转换了，也就是加了 explicit\r\n的转换构造函数的意义就只是定义了一个新的构造函数，不具有提供隐式转换机制的额外功能了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Sales_data <span class=\"title\">item1</span><span class=\"params\">(null_book)</span></span>;  <span class=\"comment\">//正确</span></span><br><span class=\"line\">Sales_data item2 = null_book; <span class=\"comment\">//错误</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>为转换显式地使用构造函数</strong></p>\r\n<p>explicit\r\n只是阻止了构造函数进行隐式转换，但是在传递实参时可以显式转换。</p>\r\n<p>可以使用 explicit 的构造函数显式地强制进行转换。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">iter.<span class=\"built_in\">combine</span>(<span class=\"built_in\">Sales_data</span>(null_book));  <span class=\"comment\">//正确</span></span><br><span class=\"line\">iter.<span class=\"built_in\">combine</span>(<span class=\"built_in\">static_cast</span>&lt;Sales_data&gt;(null_book));  <span class=\"comment\">//正确，static_cast 可以使用 explicit 的构造函数</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>7.5.5 聚合类</strong></p>\r\n<p>满足以下四个条件的类是聚合类：</p>\r\n<ol type=\"1\">\r\n<li>所有成员都是public的</li>\r\n<li>没有定义任何构造函数</li>\r\n<li>没有类内初始值</li>\r\n<li>没有基类和 virtual 函数</li>\r\n</ol>\r\n<p>聚合类可以像结构体一样用花括号初始值列表初始化。如果花括号内元素数量少于类成员数量，靠后的成员将被值初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Student stu = {<span class=\"string\">\"Li Ming\"</span>, <span class=\"number\">18</span>};</span><br></pre></td></tr></table></figure>\r\n<p><strong>7.5.6 字面值常量类</strong></p>\r\n<p><strong>constexpr 函数</strong>的参数和返回值都必须是字面值类型。</p>\r\n<p>算术类型、引用和指针都是字面值类型，此外<strong>字面值常量类</strong>也是字面值类型。</p>\r\n<p>字面值类型属于常量表达式，constexpr 就是用来声明常量表达式的。</p>\r\n<p>聚合类属于字面值常量类。</p>\r\n<p>如果不是聚合类，满足以下四个条件的类也是字面值常量类：</p>\r\n<ol type=\"1\">\r\n<li>数据成员都是字面值类型。</li>\r\n<li><strong>类至少含有一个 constexpr 构造函数</strong></li>\r\n<li>如果一个数据成员有类内初始值，则初始值必须是常量表达式（如果成员是类，则初始值必须使用成员自己的\r\nconstexpr 构造函数）</li>\r\n<li>类必须使用析构函数的默认定义。</li>\r\n</ol>\r\n<p><strong>constexpr 构造函数</strong></p>\r\n<p>类的构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr\r\n函数。</p>\r\n<p>constexpr 构造函数可以声明成 =default 或 =delete。</p>\r\n<p>constexpr 构造函数的函数体应该是空的（原因：constexpr\r\n函数的函数体只能包含一条返回语句，而构造函数不能包含返回语句）</p>\r\n<p>constexpr\r\n构造函数必须初始化所有数据成员。初始值必须是常量表达式或使用其自己的\r\nconstexpr 构造函数。</p>\r\n<p>使用前置关键字 constexpr 来声明 constexpr 构造函数</p>\r\n<p>​ class Debug{ public: constexpr Debug(bool b=true):a(b){}; private:\r\nbool a; };//定义一个类记得加分号 constexpr Debug prod(false);//定义一个\r\nDebug 类型的对象。实参应为常量表达式。</p>\r\n<p><strong>7.6 类的静态成员</strong></p>\r\n<p><strong>类的静态成员与类本身直接关联</strong>，而不是与类的对象保持关联。</p>\r\n<p>静态成员可以是 public 或 private 的。</p>\r\n<p>静态成员不与任何对象绑定在一起。</p>\r\n<p>静态成员函数不包含 this 指针，不能声明为 const 的，不能在 static\r\n函数体内使用 this 指针。</p>\r\n<p>理解：因为 static 函数不能使用 this 指针，所以它是无法使用类的非\r\nstatic 数据成员的。</p>\r\n<p><strong>定义静态成员</strong></p>\r\n<p>可以在类内或类外定义静态成员。当在类外定义时，<strong>不能重复 static\r\n关键字</strong>，static 只出现在类内的声明中。</p>\r\n<p>只有 constexpr\r\n类型的静态数据成员可以在类内初始化，但是也需要在类外定义。</p>\r\n<p>其他的静态数据成员<strong>都在类内声明，类外定义并初始化</strong>。</p>\r\n<p><strong>静态成员可以用的特殊场景</strong></p>\r\n<p>静态数据成员可以是<strong>不完全类型</strong>，比如静态数据成员的类型可以是它所属的类类型本身。</p>\r\n<p>静态成员可以作为默认实参。</p>\r\n","categories":["c++"],"tags":["c++ primer"]},{"title":"汇编语言笔记","url":"/posts/74313cf1/","content":"<p>汇编语言</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"一基础知识\">一、基础知识</h1>\r\n<hr>\r\n<h2 id=\"指令\">1、指令</h2>\r\n<p>机器指令：CPU能直接识别并执行的<a href=\"https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&amp;spm=1001.2101.3001.7020\">二进制</a>编码</p>\r\n<p>汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。</p>\r\n<p>指令：指令通常由操作码和地址码（操作数）两部分组成</p>\r\n<p>指令集：每种CPU都有自己的汇编指令集。</p>\r\n<p><a href=\"https://so.csdn.net/so/search?q=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&amp;spm=1001.2101.3001.7020\">汇编语言</a>由3类指令组成。</p>\r\n<ul>\r\n<li>汇编指令</li>\r\n<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>\r\n<li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</li>\r\n</ul>\r\n<p>编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190320203829451.png\" alt=\"在这里插入图片描述\"><br>\r\n在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p>\r\n<h2 id=\"存储器\">2、存储器</h2>\r\n<p>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</p>\r\n<p>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20200106154745358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n<img src=\"https://img-blog.csdnimg.cn/20200106152920443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n<img src=\"https://img-blog.csdnimg.cn/20200106153208896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n（以上3张图片来自王道考研 - 计算机组成原理课件）</p>\r\n<h2 id=\"总线\">3、总线</h2>\r\n<hr>\r\n<h3 id=\"总线-1\">1、总线</h3>\r\n<p>总线是连接各个部件的信息传输线，是<code>各个部件共享的传输介质</code>。</p>\r\n<p>主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有<strong>CPU、存储器、外围芯片组、扩展插槽</strong>等。扩展插槽上一般插有RAM内存条和各类接口卡。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20200106155015974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"来自唐朔飞·计算机组成原理经典课件\"></p>\r\n<p>总线根据位置分类：</p>\r\n<ul>\r\n<li><p>片内总线（芯片内部总线）</p></li>\r\n<li><p>系统总线（计算机各部件之间的信息传输线）</p>\r\n<p>根据传送信息的不同，系统总线从逻辑上又分为3类，地址总线、控制总线和数据总线。</p></li>\r\n</ul>\r\n<p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片，即内存）进行以下3类信息的交互。</p>\r\n<h3 id=\"cpu对外设的控制\">3、CPU对外设的控制</h3>\r\n<p>CPU对外设都不能直接控制，如显示器、音箱、打印机等。</p>\r\n<p>直接控制这些设备进行工作的是插在扩展插槽上的接口卡。</p>\r\n<p>扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。</p>\r\n<p>如：CPU无法直接控制显示器，但CPU可以直接控制显卡，从而实现对显示器的间接控制</p>\r\n<h2 id=\"内存地址空间\">4、内存地址空间</h2>\r\n<p>CPU将系统中各类存储器看作一个逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。<br>\r\n对于CPU，所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力限制。(或许就是计组中学的统一编址吧)<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190320225301671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据（对ROM写无效）。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190320225820276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<h1 id=\"二寄存器\">二、寄存器</h1>\r\n<hr>\r\n<h2 id=\"寄存器\">1、寄存器</h2>\r\n<p>CPU组成：</p>\r\n<ul>\r\n<li>运算器：信息处理</li>\r\n<li>控制器：控制各种器件进行工作</li>\r\n<li>寄存器：信息存储</li>\r\n<li>内部总线</li>\r\n</ul>\r\n<p>8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190320231551626.png\" alt=\"在这里插入图片描述\"></p>\r\n<p>16位结构CPU具有下面几方面的结构特性。</p>\r\n<ul>\r\n<li>运算器一次最多可以处理16位的数据；</li>\r\n<li>寄存器的最大宽度为16位；</li>\r\n<li>寄存器和运算器之间的通路为16位。</li>\r\n</ul>\r\n<p>8086CPU可以一次性处理以下两种尺寸的数据。</p>\r\n<ul>\r\n<li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li>\r\n<li>字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)</li>\r\n<li>8086采用小端模式：高地址存放高位字节，低地址存放低位字节。</li>\r\n</ul>\r\n<h2 id=\"通用寄存器\">2、通用寄存器</h2>\r\n<p><strong>通用寄存器</strong>：通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器，</p>\r\n<p>16位</p>\r\n<p>8高位</p>\r\n<p>8低位</p>\r\n<p>AX</p>\r\n<p>AH</p>\r\n<p>AL</p>\r\n<p>BX</p>\r\n<p>BH</p>\r\n<p>BL</p>\r\n<p>CX</p>\r\n<p>CH</p>\r\n<p>CL</p>\r\n<p>DX</p>\r\n<p>DH</p>\r\n<p>DL</p>\r\n<p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</p>\r\n<p>一个8位寄存器所能存储的数据范围是0 ~ 28-1。</p>\r\n<h2 id=\"cpu给出物理地址的方法\">3、8086CPU给出物理地址的方法</h2>\r\n<p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。<br>\r\n8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。<br>\r\n从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。<br>\r\n8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190320232455205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n当8086CPU要读写内存时：</p>\r\n<ol type=\"1\">\r\n<li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li>\r\n<li>地址加法器将两个16位地址合成为一个20位的物理地址；</li>\r\n</ol>\r\n<p>地址加法器采用物理地址 = 段地址×16 +\r\n偏移地址的方法用段地址和偏移地址合成物理地址。</p>\r\n<p>例如，8086CPU要访问地址为<code>123C8H</code>的内存单元，<code>1230H</code>左移一位(空出4位)加上<code>00C8H</code>合成<code>123C8H</code></p>\r\n<h2 id=\"段寄存器\">4、段寄存器</h2>\r\n<p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。</p>\r\n<p>用一个段存放数据，将它定义为“数据段”；</p>\r\n<p>用一个段存放代码，将它定义为“代码段”；</p>\r\n<p>用一个段当作栈，将它定义为“栈段”。</p>\r\n<p>注意：</p>\r\n<ul>\r\n<li>一个段的起始地址一定是16的倍数；</li>\r\n<li>偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。</li>\r\n<li>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</li>\r\n</ul>\r\n<p>段寄存器：8086CPU有4个段寄存器：<code>CS、DS、SS、ES</code>，提供内存单元的段地址。</p>\r\n<h3 id=\"cs和ip\">1、CS和IP</h3>\r\n<p>CS为代码段寄存器，IP为指令指针寄存器，CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，即将CS:IP指向的内容当作指令执行。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190321105503491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n8086CPU的工作过程简要描述</p>\r\n<ol type=\"1\">\r\n<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li>\r\n<li>IP=IP+所读取指令的长度，从而指向下一条指令；</li>\r\n<li>执行指令。转到步骤1，重复这个过程。</li>\r\n</ol>\r\n<p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p>\r\n<p>8086CPU提供转移指令修改CS、IP的内容。</p>\r\n<ul>\r\n<li><p>jmp\r\n段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：<code>jmp 2AE3:3</code></p></li>\r\n<li><p>jmp\r\n某一合法寄存器：仅修改IP的内容。如：<code>jmp ax</code>。在含义上好似：<code>mov IP，ax</code></p></li>\r\n</ul>\r\n<p>8086CPU不支持将数据直接送入段寄存器的操作，这属于8086CPU硬件设计</p>\r\n<h3 id=\"ds-和-address\">2、DS 和 [address]</h3>\r\n<p>DS寄存器：通常用来存放要访问数据的段地址</p>\r\n<p>[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中</p>\r\n<p>通过数据段段地址和偏移地址即可定位内存单元。</p>\r\n<pre><code>mov bx, 1000H ;8086CPU不支持将数据直接送入段寄存器的操作\r\n\r\nmov ds, bx ;ds存放数据段地址\r\n\r\nmov [0], al ;将al数据（1字节）存到1000H段的0偏移地址处，即10000H\r\n\r\nmov ax, [2] ;将数据段偏移地址2处的一个字（8086为2字节）存放到ax寄存器\r\n\r\nadd cx, [4] ;将偏移地址4处的一个字数据加上cx寄存器数据放到cx寄存器\r\n\r\nsub dx, [6] ;dx寄存器数据减去数据段偏移地址6处的字数据存到dx</code></pre>\r\n<h3 id=\"ss-和-sp\">3、SS 和 SP</h3>\r\n<p>在基于8086CPU编程的时候，可以将一段内存当作栈来使用。</p>\r\n<p>栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，<strong>SS:SP</strong>指向栈顶元素</p>\r\n<p>8086CPU中，入栈时，栈顶从高地址向低地址方向增长。</p>\r\n<p><code>push ax</code>表示将寄存器ax中的数据送入栈中，由两步完成。</p>\r\n<ol type=\"1\">\r\n<li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；</li>\r\n<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190321113400430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\r\n</ol>\r\n<p><code>pop ax</code>表示从栈顶取出数据送入ax，由以下两步完成。</p>\r\n<ol type=\"1\">\r\n<li>将SS:SP指向的内存单元处的数据送入ax中；</li>\r\n<li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>\r\n</ol>\r\n<p><strong>实验</strong></p>\r\n<ol type=\"1\">\r\n<li><p>将10000H~1000FH这段空间当作栈，初始状态栈是空的；</p></li>\r\n<li><p>设置AX=001AH，BX=001BH；</p></li>\r\n<li><p>将AX、BX中的数据入栈；</p></li>\r\n<li><p>然后将AX、BX清零；</p></li>\r\n<li><p>从栈中恢复AX、BX原来的内容。</p>\r\n<p>mov ax, 1000H<br>\r\nmov ss, ax<br>\r\nmov sp, 0010H ;初始化栈顶<br>\r\nmov ax, 001AH<br>\r\nmov bx, 001BH</p>\r\n<p>push ax<br>\r\npush bx ;ax、bx入栈</p>\r\n<p>sub ax, ax ;将ax清零，也可以用mov ax，0，<br>\r\n;sub ax，ax的机器码为2个字节，<br>\r\n;mov ax，0的机器码为3个字节。</p>\r\n<p>sub bx, bx</p>\r\n<p>pop bx ;从栈中恢复ax、bx原来的数据<br>\r\npop ax ;</p></li>\r\n</ol>\r\n<h1 id=\"三第一个程序\">三、第一个程序</h1>\r\n<h2 id=\"汇编程序从写出到执行的过程\">1、汇编程序从写出到执行的过程</h2>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190321114839761.png\" alt=\"在这里插入图片描述\"><br>\r\n加载后，CPU的CS:IP指向程序的第一条指令（即程序的入口）</p>\r\n<pre><code>;1.asm\r\nassume cs:codesg ;将用作代码段的段codesg和段寄存器cs联系起来。\r\n\r\ncodesg segment ;定义一个段，段的名称为“codesg”，这个段从此开始\r\n               ;codesg是一个标号，作为一个段的名称，最终被编译连接成一个段的段地址\r\n\r\n    mov ax, 0123H\r\n    mov bx, 0456H \r\n    add ax, bx\r\n    add ax, ax \r\n    \r\n    mov ax, 4c00H \r\n    int 21H ;这两条指令实现程序的返回\r\n    \r\ncodesg ends ;名称为“codesg”的段到此结束\r\n\r\nend ;编译器在编译汇编程序的过程中，碰到了伪指令end，结束对源程序的编译</code></pre>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190321115112266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190321115301209.png\" alt=\"在这里插入图片描述\"></p>\r\n<h2 id=\"程序执行过程跟踪\">2、程序执行过程跟踪</h2>\r\n<p>DOS系统中.EXE文件中的程序的加载过程<br>\r\n<img src=\"https://img-blog.csdnimg.cn/2019032114041883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190321141657458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<hr>\r\n<h1 id=\"四bx-和-loop指令\">四、[bx] 和 loop指令</h1>\r\n<hr>\r\n<h2 id=\"bx-和-loop指令\">1、[bx] 和 loop指令</h2>\r\n<p><code>[bx]</code>\r\n的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p>\r\n<p><code>loop</code>指令的格式是：loop\r\n标号，CPU执行loop指令的时候，要进行两步操作，</p>\r\n<ol type=\"1\">\r\n<li><ol start=\"110\" type=\"i\">\r\n<li>= (cx) - 1；</li>\r\n</ol></li>\r\n<li>判断 cx\r\n中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>\r\n</ol>\r\n<p>例如：计算212</p>\r\n<pre><code>assume cs:code \r\n\r\ncode segment \r\n    mov ax, 2\r\n    \r\n    mov cx, 11 ;循环次数\r\ns:  add ax, ax \r\n    loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，\r\n               ;这个地址处有一条指令：add ax，ax。\r\n               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前\r\n               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。\r\n    \r\n    mov ax,4c00h \r\n    int 21h \r\ncode ends \r\nend</code></pre>\r\n<p><strong>loop 和 [bx] 的联合应用</strong></p>\r\n<p>计算<code>ffff:0 ~ ffff:b</code>单元中的数据的和，结果存储在dx中</p>\r\n<p>问题分析：</p>\r\n<ol type=\"1\">\r\n<li>这些内存单元都是字节型数据范围0 ~ 255\r\n，12个字节数据和不会超过65535，dx可以存下</li>\r\n<li>对于8位数据不能直接加到 dx</li>\r\n</ol>\r\n<p>解决方案：</p>\r\n<p>用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx</p>\r\n<pre><code>assume cs:code \r\n\r\ncode segment \r\n    mov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头，所以要在前面加0。\r\n    mov ds, ax \r\n    mov bx, 0   ;初始化ds:bx指向ffff:0\r\n    mov dx, 0   ;初始化累加寄存器dx，（dx）= 0\r\n    \r\n    mov cx, 12  ;初始化循环计数寄存器cx，（cx）= 12\r\ns:  mov al, [bx]\r\n    mov ah, 0\r\n    add dx, ax  ;间接向dx中加上（（ds）* 16 +（bx））单元的数值\r\n    inc bx      ;ds:bx指向下一个单元\r\n    loop s \r\n    \r\n    mov ax, 4c00h \r\n    int 21h \r\ncode ends \r\nend</code></pre>\r\n<h2 id=\"段前缀\">2、段前缀</h2>\r\n<pre><code>mov ax, ds:[bx]\r\nmov ax, cs:[bx]\r\nmov ax, ss:[bx]\r\nmov ax, es:[bx]\r\nmov ax, ss:[0]\r\nmov ax, cs:[0]</code></pre>\r\n<p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>\r\n的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。</p>\r\n<p><strong>段前缀的使用</strong></p>\r\n<p>将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p>\r\n<pre><code>assume cs:code \r\n\r\ncode segment \r\n    mov ax, 0ffffh \r\n    mov ds, ax   ;（ds）= 0ffffh \r\n    mov ax, 0020h\r\n    mov es, ax   ;（es）= 0020h     0:200 等效于 0020:0\r\n    mov bx, 0    ;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0\r\n    \r\n    mov cx，12   ;（cx）=12，循环12次\r\ns:  mov dl，[bx] ;（d1）=（（ds）* 16+（bx）），将ffff:bx中的字节数据送入dl \r\n    mov es:[bx]，dl ;（（es）*16+（bx））=（d1），将dl中的数据送入0020:bx \r\n    inc bx  ;（bx）=（bx）+1\r\n    loop s \r\n    \r\n    mov ax，4c00h \r\n    int 21h \r\ncode ends \r\nend</code></pre>\r\n<h1 id=\"五包含多个段的程序\">五、包含多个段的程序</h1>\r\n<p>程序中对段名的引用，将被编译器处理为一个表示段地址的数值。</p>\r\n<pre><code>mov ax, data \r\n\r\nmov ds, ax \r\n\r\nmov bx, ds:[6]</code></pre>\r\n<p>在代码段中使用数据</p>\r\n<pre><code>;计算 8 个数据的和存到 ax 寄存器\r\nassume cs:code \r\n\r\ncode segment \r\n\r\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;define word 定义8个字形数据\r\n\r\n    start:  mov bx, 0  ;标号start\r\n            mov ax, 0  \r\n            \r\n            mov cx, 8\r\n    s:      add ax, cs:[bx]\r\n            add bx, 2\r\n            loop s \r\n            \r\n            mov ax, 4c00h \r\n            int 21h \r\ncode ends\r\nend start    ;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方\r\n             ;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</code></pre>\r\n<p>在代码段中使用栈</p>\r\n<pre><code>;利用栈，将程序中定义的数据逆序存放。\r\nassume cs:codesg \r\n\r\ncodesg segment \r\n    dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h ; 0-15单元\r\n    dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0 ; 16-47单元作为栈使用\r\n            \r\n    start:  mov ax, cs \r\n            mov ss, ax \r\n            mov sp, 30h ;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d\r\n            mov bx, 0\r\n            \r\n            mov cx, 8\r\n    s:      push cs:[bx]\r\n            add bx, 2\r\n            loop s    ;以上将代码段0~15单元中的8个字型数据依次入栈\r\n            \r\n            mov bx, 0\r\n            \r\n            mov cx, 8\r\n    s0:     pop cs:[bx]     \r\n            add bx，2\r\n            loop s0   ;以上依次出栈8个字型数据到代码段0~15单元中\r\n            \r\n            mov ax，4c00h \r\n            int 21h \r\ncodesg ends \r\nend start   ;指明程序的入口在start处</code></pre>\r\n<p>将数据、代码、栈放入不同的段</p>\r\n<pre><code>assume cs:code,ds:data,ss:stack \r\n\r\ndata segment \r\n    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h ;0-15单元\r\ndata ends \r\n\r\nstack segment \r\n    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;0-31单元\r\nstack ends \r\n\r\ncode segment \r\n    start:  mov ax, stack;将名称为“stack”的段的段地址送入ax\r\n            mov ss, ax\r\n            mov sp, 20h  ;设置栈顶ss:sp指向stack:20。 20h = 32d\r\n            \r\n            mov ax, data ;将名称为“data”的段的段地址送入ax\r\n            mov ds, ax   ;ds指向data段\r\n            \r\n            mov bx, 0    ;ds:bx指向data段中的第一个单元\r\n            \r\n            mov cx, 8\r\n    s:      push [bx]\r\n            add bx, 2\r\n            loop s       ;以上将data段中的0~15单元中的8个字型数据依次入栈\r\n            \r\n            mov bx, 0\r\n            \r\n            mov cx, 8\r\n    s0:     pop [bx]\r\n            add bx, 2\r\n            loop s0      ;以上依次出栈8个字型数据到data段的0~15单元中\r\n            \r\n            mov ax, 4c00h \r\n            int 21h \r\ncode ends\r\nend start\r\n;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，\r\n;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</code></pre>\r\n<p>关于可执行文件结构与程序入口的详细描述参考：<a href=\"https://blog.csdn.net/qq_39654127/article/details/97905901\">PE文件结构</a></p>\r\n<h1 id=\"六更灵活的定位内存地址的方法\">六、更灵活的定位内存地址的方法</h1>\r\n<hr>\r\n<h2 id=\"and-和-or\">1、and 和 or</h2>\r\n<p>and指令：逻辑与指令，按位进行与运算。</p>\r\n<p><code>mov al, 01100011B</code><br>\r\n<code>and al, 00111011B</code></p>\r\n<p>执行后：<code>al=00100011B</code>即都为1才为1</p>\r\n<p>or指令：逻辑或指令，按位进行或运算。</p>\r\n<p><code>mov al, 01100011B</code><br>\r\n<code>or al, 00111011B</code><br>\r\n执行后：<code>al=01111011B</code> 即只要有一个为1就为1</p>\r\n<p><strong>关于ASCII码</strong><br>\r\n世界上有很多编码方案，有一种方案叫做ASCII编码，是在计算机系统中通常被采用的。简单地说，所谓编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象。比如说，在ASCII编码方案中，用61H表示“a”，62H表示“b”。一种规则需要人们遵守才有意义。</p>\r\n<p>在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，<br>\r\n61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。我们可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCIⅡ码，61H。如何提供？当然是写入显存中。</p>\r\n<p><strong>以字符形式给出的数据</strong></p>\r\n<pre><code>assume cs:code,ds:data \r\n\r\ndata segment \r\n    db 'unIx'   ;相当于“db 75H，6EH，49H，58H”\r\n    db 'foRK'\r\ndata ends \r\n\r\ncode segment\r\nstart:  mov al, 'a'  ;相当于“mov al, 61H”，“a”的ASCI码为61H；\r\n        mov b1, 'b'\r\n        \r\n        mov ax, 4c00h \r\n        int 21h \r\ncode ends\r\nend start</code></pre>\r\n<p><strong>大小写转换的问题</strong><br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190321194022547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n小写字母的ASCII码值比大写字母的ASCII码值大20H</p>\r\n<p>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</p>\r\n<pre><code>assume cs:codesg,ds:datasg \r\n\r\ndatasg segment \r\n    db 'BaSiC'\r\n    db 'iNfOrMaTion'\r\ndatasg end\r\n\r\ncodesg segment \r\n    start:  mov ax, datasg \r\n            mov ds, ax  ;设置ds 指向 datasg段\r\n        \r\n            mov bx, 0   ;设置（bx）=0，ds:bx指向’BaSic’的第一个字母\r\n            \r\n            mov cx, 5        ;设置循环次数5，因为’Basic'有5个字母\r\n    s:      mov al, [bx]     ;将ASCII码从ds:bx所指向的单元中取出\r\n            and al, 11011111B;将al中的ASCII码的第5位置为0，变为大写字母\r\n            mov [bx], al     ;将转变后的ASCII码写回原单元\r\n            inc bx           ;（bx）加1，ds:bx指向下一个字母\r\n            loop s \r\n            \r\n            mov bx, 5   ;设置（bx）=5，ds:bx指向，iNfOrMaTion'的第一个字母\r\n            \r\n            mov cx, 11  ;设置循环次数11，因为‘iNfOrMaTion'有11个字母\r\n    s0:     mov al, [bx]\r\n            or al, 00100000B;将a1中的ASCII码的第5位置为1，变为小写字母\r\n            mov [bx], al \r\n            inc bx\r\n            loop s0\r\n            \r\n            mov ax, 4c00h \r\n            int 21h \r\ncodesg ends</code></pre>\r\n<h2 id=\"bxidata\">2、[bx+idata]</h2>\r\n<p>[bx+idata]表示一个内存单元, 例如：<code>mov ax, [bx+200]</code><br>\r\n该指令也可以写成如下格式：</p>\r\n<pre><code>mov ax, [200+bx]\r\n\r\nmov ax, 200[bx]\r\n\r\nmov ax, [bx].200</code></pre>\r\n<p>用[bx+idata]的方式进行数组的处理</p>\r\n<pre><code>assume cs:codesg,ds:datasg \r\n\r\ndatasg segment \r\n    db 'BaSiC';转为大写\r\n    db 'MinIx';转为小写\r\ndatasg ends\r\n\r\ncodesg segment\r\n    start:\r\n        mov ax, datasg \r\n        mov ds, ax \r\n        mov bx, 0  ;初始ds:bx\r\n    \r\n        mov cx, 5\r\n    s:  mov al, 0[bx]  \r\n        and al, 11011111b ;转为大写字母\r\n        mov 0[bx], al ;写回\r\n        mov al, 5[bx]  ;[5 + bx]\r\n        or al, 00100000b ;转为小写字母\r\n        mov 5[bx], al \r\n        inc bx\r\n        loop s\r\n        \r\n        mov ax, 4c00h \r\n        int 21h\r\ncodesg ends\r\nend start</code></pre>\r\n<p>C语言描述</p>\r\n<pre><code>int main()\r\n{\r\n    char a[] = \"BaSic\";\r\n    char b[] = \"MinIX\";\r\n    \r\n    int i = 0;\r\n    \r\n    do\r\n    {\r\n        a[i] = a[i] &amp; 0xDF;\r\n        b[i] = b[i] | 0x20;\r\n        i++;\r\n    } while(i &lt; 5);\r\n\r\n    return 0;\r\n } </code></pre>\r\n<h2 id=\"si-di-与-寻址方式的灵活应用\">3、SI 、DI 与\r\n寻址方式的灵活应用</h2>\r\n<p><strong>1、si 、di</strong></p>\r\n<p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>\r\n<pre><code>assume cs: codesg, ds: datasg \r\n\r\ndatasg segment \r\n    db 'welcome to masm!';用si和di实现将字符串‘welcome to masm！\"复制到它后面的数据区中。\r\n    db '................'\r\ndatasg ends\r\n\r\ncodesg segment \r\n    start:  mov ax, datasg \r\n            mov ds, ax \r\n            mov si, 0\r\n            \r\n            mov cx, 8\r\n    s:      mov ax, 0[si] ;[0 + si]\r\n            mov 16[si], ax ;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁\r\n            add si, 2 \r\n            loop s \r\n            \r\n            mov ax, 4c00h \r\n            int 21h \r\ncodesg ends \r\nend start</code></pre>\r\n<p><strong>2、[bx + si] 和 [bx + di]</strong></p>\r\n<p>[bx+si]和[bx+di]的含义相似</p>\r\n<p>[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）</p>\r\n<p>指令<code>mov ax, [bx + si]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>\r\n<p>该指令也可以写成如下格式：<code>mov ax, [bx][si]</code></p>\r\n<p><strong>3、[bx+si+idata]和[bx+di+idata]</strong><br>\r\n[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata</p>\r\n<p>指令<code>mov ax，[bx+si+idata]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p>\r\n<p><strong>4、不同的寻址方式的灵活应用</strong><br>\r\n<code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元；<br>\r\n<code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元；<br>\r\n<code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；<br>\r\n<code>[bx+si]</code>用两个变量表示地址；<br>\r\n<code>[bx+si+idata]</code>用两个变量和一个常量表示地址。</p>\r\n<pre><code>;将datasg段中每个单词改为大写字母\r\nassume cs:codesg,ds:datasg,ss:stacksg \r\n\r\ndatasg segment\r\n    db 'ibm            ' ;16\r\n    db 'dec            ' \r\n    db 'dos            '\r\n    db 'vax            '  ;看成二维数组\r\ndatasg ends \r\n\r\nstacksg segment ;定义一个段，用来做栈段，容量为16个字节\r\n    dw 0, 0, 0, 0, 0, 0, 0, 0\r\nstacksg ends \r\n\r\ncodesg segment \r\n    start:  mov ax, stacksg \r\n            mov ss, ax\r\n            mov sp, 16 \r\n            mov ax, datasg \r\n            mov ds, ax \r\n            mov bx, 0 ;初始ds:bx\r\n            \r\n            ;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存\r\n            mov cx, 4\r\n    s0:     push cx ;将外层循环的cx值入栈\r\n            mov si, 0\r\n            mov cx, 3   ;cx设置为内层循环的次数\r\n    s:      mov al, [bx+si]\r\n            and al, 11011111b ;每个字符转为大写字母\r\n            mov [bx+si], al \r\n            inc si\r\n            loop s \r\n            \r\n            add bx, 16 ;下一行\r\n            pop cx  ;恢复cx值\r\n            loop s0 ;外层循环的loop指令将cx中的计数值减1\r\n            \r\n            mov ax，4c00H \r\n            int 21H \r\ncodesg ends\r\nend start</code></pre>\r\n<h1 id=\"七数据处理的两个基本问题\">七、数据处理的两个基本问题</h1>\r\n<h2 id=\"bxsidi和bp\">1、 bx、si、di和bp</h2>\r\n<p>在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。</p>\r\n<p>在[\r\n]中，这4个寄存器可以单个出现，或只能以4种组合出现：<code>bx和si、bx和di</code>、<code>bp和si、bp和di</code>。</p>\r\n<p>只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址,\r\n段地址就默认在ss中</p>\r\n<h2 id=\"机器指令处理的数据在什么地方\">2、机器指令处理的数据在什么地方</h2>\r\n<p>数据处理大致可分为3类：读取、写入、运算。</p>\r\n<p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口<br>\r\n<img src=\"https://img-blog.csdnimg.cn/2019032120283492.png\" alt=\"在这里插入图片描述\"></p>\r\n<h2 id=\"汇编语言中数据位置的表达\">3、汇编语言中数据位置的表达</h2>\r\n<p>汇编语言中用3个概念来表达数据的位置</p>\r\n<ul>\r\n<li><p>立即数（idata）</p>\r\n<p>mov ax, 1\r\n;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）<br>\r\nadd bx, 2000h ;在汇编语言中称为：立即数（idata）<br>\r\nor bx, 00010000b<br>\r\nmov al, 'a'</p></li>\r\n<li><p>寄存器</p>\r\n<p>mov ax, bx\r\n;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。<br>\r\nmov ds, ax<br>\r\npush bx<br>\r\nmov ds:[0], bx<br>\r\npush ds<br>\r\nmov ss, ax<br>\r\nmov sp, ax</p></li>\r\n<li><p>段地址（SA）和偏移地址（EA）</p>\r\n<p>;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。<br>\r\nmov ax, [0]<br>\r\nmov ax, [di]<br>\r\nmov ax, [bx+8]<br>\r\nmov ax, [bx+si]<br>\r\nmov ax, [bx+si+8] ;以上段地址默认在ds中</p>\r\n<p>mov ax, [bp]<br>\r\nmov ax, [bp+8]<br>\r\nmov ax, [bp+si]<br>\r\nmov ax, [bp+si+8] ;以上段地址默认在ss中</p>\r\n<p>mov ax, ds:[bp]<br>\r\nmov ax, es:[bx]<br>\r\nmov ax, ss:[bx+si]<br>\r\nmov ax, cs:[bx+si+8] ;显式给出存放段地址的寄存器</p></li>\r\n</ul>\r\n<p>寻址方式<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190321213006102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<h2 id=\"指令要处理的数据有多长\">4、指令要处理的数据有多长</h2>\r\n<p>8086CPU的指令，可以处理两种尺寸的数据，byte和word</p>\r\n<ol type=\"1\">\r\n<li><p>通过寄存器名指明要处理的数据的尺寸。<br>\r\n例如： <code>mov al, ds:[0]</code> 寄存器al指明了数据为1字节</p></li>\r\n<li><p>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为<code>word</code>或<code>byte</code>。<br>\r\n例如：<code>mov byte ptr ds:[0], 1</code> byte ptr\r\n指明了指令访问的内存单元是一个字节单元</p></li>\r\n<li><p>有些指令默认了访问的是字单元还是字节单元<br>\r\n例如，<code>push [1000H]</code>，push 指令只进行字操作。</p></li>\r\n</ol>\r\n<h2 id=\"寻址方式的综合应用\">5、寻址方式的综合应用</h2>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190321215930774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<pre><code>mov ax, seg \r\nmov ds, ax \r\nmov bx, 60h   ;确定记录地址，ds:bx \r\n\r\nmov word ptr [bx+0ch], 38   ;排名字段改为38  [bx].0ch\r\nadd word ptr [bx+0eh], 70   ;收入字段增加70  [bx].0eh\r\nmov si, 0   ;用si来定位产品字符串中的字符\r\nmov byte ptr [bx+10h+si], 'V'   ;[bx].10h[si]\r\ninc si \r\nmov byte ptr [bx+10h+si], 'A'\r\ninc si \r\nmov byte ptr [bx+10h+si], 'X'</code></pre>\r\n<p>C语言描述</p>\r\n<pre><code>/*定义一个公司记录的结构体*/\r\nstruct company\r\n{\r\n    char cn[3];/*公司名称*/\r\n    char hn[9];/*总裁姓名*/\r\n    int pm;/*排名*/\r\n    int sr;/*收入*/\r\n    char cp[3];/*著名产品*/\r\n};\r\n//sizeof (struct company) == 24\r\n\r\nint main()\r\n{\r\n    /*定义一个公司记录的变量，内存中将存有一条公司的记录*/\r\n    struct company dec = {\"DEC\", \"Ken Olsen\", 137, 40, \"PDP\"};\r\n\r\n    int i;\r\n\r\n    dec.pm = 38;\r\n    dec.sr = dec.sr + 70;\r\n\r\n    i = 0;\r\n    dec.cp[i] = 'V'; //mov byte ptr [bx].10h[si], 'V'\r\n    i++;\r\n    dec.cp[i] = 'A';\r\n    i++;\r\n    dec.cp[i] = 'X';\r\n\r\n    return 0;\r\n}</code></pre>\r\n<p>​</p>\r\n<h2 id=\"div指令dddupmul指令\">6、div指令、dd、dup、mul指令</h2>\r\n<p><strong>div是除法指令</strong></p>\r\n<ol type=\"1\">\r\n<li><p>除数：有8位和16位两种，在一个<code>寄存器</code>或<code>内存单元</code>中。</p></li>\r\n<li><p>被除数：默认放在<code>AX</code>或<code>DX和AX</code>中，<br>\r\n如果除数为8位，被除数则为16位，默认在AX中存放；<br>\r\n如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</p></li>\r\n<li><p>结果：<br>\r\n如果除数为8位，则<code>AL存储除法操作的商</code>，<code>AH存储除法操作的余数</code>；<br>\r\n如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p>\r\n<p>;利用除法指令计算100001/100。<br>\r\n;100001D = 186A1H<br>\r\nmov dx, 1<br>\r\nmov ax, 86A1H ;(dx)*10000H+(ax)=100001<br>\r\nmov bx, 100<br>\r\ndiv bx</p>\r\n<p>;利用除法指令计算1001/100<br>\r\nmov ax, 1001<br>\r\nmov bl, 100<br>\r\ndiv b1</p></li>\r\n</ol>\r\n<p><strong>伪指令dd</strong></p>\r\n<p>db和dw定义字节型数据和字型数据。</p>\r\n<p>dd是用来定义dword（double word，双字）型数据的<a href=\"https://so.csdn.net/so/search?q=%E4%BC%AA%E6%8C%87%E4%BB%A4&amp;spm=1001.2101.3001.7020\">伪指令</a></p>\r\n<p><strong>操作符dup</strong></p>\r\n<p>dup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。<br>\r\n它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p>\r\n<pre><code>db 3 dup (0)       ;定义了3个字节，它们的值都是0，相当于db 0，0，0。\r\ndb 3 dup (0, 1, 2) ;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db 0，1，2，0，1，2，0，1，2。\r\ndb 3 dup ('abc', 'ABC') ;定义了18个字节，它们是abcABCabcABCabcABCC，相当于db 'abc', 'ABC' ,'abc' , 'ABC, 'abc', 'ABC'。</code></pre>\r\n<p><strong>mul 指令</strong></p>\r\n<p>mul是乘法指令，使用 mul\r\n做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p>\r\n<ul>\r\n<li><p>8 位： <code>AL</code>中和\r\n<code>8位寄存器</code>或<code>内存字节单元</code>中；</p></li>\r\n<li><p>16 位： <code>AX</code>中和\r\n<code>16 位寄存器</code>或<code>内存字单元</code>中。</p></li>\r\n</ul>\r\n<p>结果</p>\r\n<ul>\r\n<li><p>8位：AX中；</p></li>\r\n<li><p>16位：DX（高位）和 AX（低位）中。</p></li>\r\n</ul>\r\n<p>格式：<code>mul 寄存器</code> 或 <code>mul 内存单元</code></p>\r\n<pre><code>;计算100*10\r\n;100和10小于255，可以做8位乘法\r\nmov al,100\r\nmov bl,10\r\nmul bl\r\n\r\n;结果： (ax)=1000（03E8H） </code></pre>\r\n<p>​</p>\r\n<pre><code>;计算100*10000\r\n;100小于255，可10000大于255，所以必须做16位乘法，程序如下：\r\nmov ax,100\r\nmov bx,10000\r\nmul bx\r\n\r\n;结果： (ax)=4240H，(dx)=000FH     （F4240H=1000000）</code></pre>\r\n<p>​</p>\r\n<h1 id=\"八转移指令的原理\">八、转移指令的原理</h1>\r\n<hr>\r\n<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>\r\n<p>8086CPU的转移行为有以下几类。</p>\r\n<ul>\r\n<li>只修改IP时，称为<code>段内转移</code>，比如：<code>jmp ax</code>。</li>\r\n<li>同时修改CS和IP时，称为<code>段间转移</code>，比如：<code>jmp 1000:0</code>。</li>\r\n</ul>\r\n<p>由于转移指令对IP的修改范围不同，段内转移又分为：<code>短转移和近转移</code>。</p>\r\n<ul>\r\n<li>短转移IP的修改范围为<code>-128 ~ 127</code>。</li>\r\n<li>近转移IP的修改范围为<code>-32768 ~ 32767</code>。</li>\r\n</ul>\r\n<p>8086CPU的转移指令分为以下几类。</p>\r\n<ul>\r\n<li>无条件转移指令（如：jmp）</li>\r\n<li>条件转移指令</li>\r\n<li>循环指令（如：loop）</li>\r\n<li>过程</li>\r\n<li>中断</li>\r\n</ul>\r\n<h2 id=\"操作符offset\">1、操作符offset</h2>\r\n<p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p>\r\n<pre><code>;将s处的一条指令复制到s0处\r\nassume cs:codesg\r\ncodesg segment\r\n s:   mov ax, bx           ;（mov ax,bx 的机器码占两个字节）\r\n      mov si, offset s     ;获得标号s的偏移地址\r\n      mov di, offset s0    ;获得标号s0的偏移地址\r\n      \r\n      mov ax, cs:[si]\r\n      mov cs:[di], ax\r\n s0:  nop                     ;（nop的机器码占一个字节）\r\n      nop\r\n codesg ends\r\n ends</code></pre>\r\n<h2 id=\"jmp指令\">2、jmp指令</h2>\r\n<p>jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p>\r\n<p>jmp指令要给出两种信息：</p>\r\n<ul>\r\n<li>转移的目的地址</li>\r\n<li>转移的距离（段间转移、段内短转移，段内近转移）</li>\r\n</ul>\r\n<p><code>jmp short 标号</code> <code>jmp near ptr 标号</code>\r\n<code>jcxz 标号</code> <code>loop 标号</code> 等几种汇编指令，它们对\r\nIP的修改</p>\r\n<p>是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p>\r\n<h3 id=\"依据位移进行转移的jmp指令\">1、依据位移进行转移的jmp指令</h3>\r\n<p><code>jmp short 标号</code>（段内短转移）</p>\r\n<p>指令“<code>jmp short 标号</code>”的功能为<code>(IP)=(IP)+8位位移</code>，转到标号处执行指令</p>\r\n<p>（1）8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址；</p>\r\n<p>（2）short指明此处的位移为8位位移；</p>\r\n<p>（3）8位位移的范围为-128~127，用补码表示</p>\r\n<p>（4）8位位移由编译程序在编译时算出。</p>\r\n<pre><code>assume cs:codesg\r\ncodesg segment\r\n  start:mov ax,0\r\n        jmp short s ;s不是被翻译成目的地址\r\n        add ax, 1\r\n      s:inc ax ;程序执行后， ax中的值为 1 \r\ncodesg ends\r\nend start</code></pre>\r\n<p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移</p>\r\n<p><strong>jmp short s指令的读取和执行过程：</strong></p>\r\n<ol type=\"1\">\r\n<li>(CS)=0BBDH，(IP)=0006，上一条指令执行结束后CS:IP指向EB 03（jmp short\r\ns的机器码）；</li>\r\n<li>读取指令码EB 03进入指令缓冲器；</li>\r\n<li>(IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 0008，CS:IP指向add\r\nax,1；</li>\r\n<li>CPU指行指令缓冲器中的指令EB 03；</li>\r\n<li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li>\r\n</ol>\r\n<p><code>jmp near ptr 标号</code> （段内近转移）</p>\r\n<p>指令“<code>jmp near ptr 标号</code>”的功能为：<code>(IP) = (IP) + 16位位移</code>。</p>\r\n<h3 id=\"转移的目的地址在指令中的jmp指令\">2、转移的目的地址在指令中的jmp指令</h3>\r\n<p><code>jmp far ptr 标号</code>（段间转移或远转移）</p>\r\n<p>指令 “<code>jmp far ptr 标号</code>” 功能如下：</p>\r\n<ul>\r\n<li><p>(CS) = 标号所在段的段地址；</p></li>\r\n<li><p>(IP) = 标号所在段中的偏移地址。</p></li>\r\n<li><p>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</p>\r\n<p>assume cs:codesg<br>\r\ncodesg segment<br>\r\nstart: mov ax, 0<br>\r\nmov bx, 0<br>\r\njmp far ptr s ;s被翻译成转移的目的地址0B01 BD0B<br>\r\ndb 256 dup (0) ;转移的段地址：0BBDH，偏移地址：010BH<br>\r\ns: add ax,1<br>\r\ninc ax<br>\r\ncodesg ends<br>\r\nend start</p></li>\r\n</ul>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190322151439754.png\" alt=\"在这里插入图片描述\"></p>\r\n<h3 id=\"转移地址在寄存器或内存中的jmp指令\">3、转移地址在寄存器或内存中的jmp指令</h3>\r\n<p><code>jmp 16位寄存器</code> 功能：<code>IP =（16位寄存器）</code></p>\r\n<p>转移地址在内存中的jmp指令有两种格式：</p>\r\n<ul>\r\n<li><code>jmp word ptr 内存单元地址</code>（段内转移）</li>\r\n</ul>\r\n<p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p>\r\n<pre><code>mov ax, 0123H\r\nmov ds:[0], ax\r\njmp word ptr ds:[0]\r\n;执行后，(IP)=0123H</code></pre>\r\n<ul>\r\n<li><code>jmp dword ptr 内存单元地址</code>（段间转移）</li>\r\n</ul>\r\n<p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p>\r\n<ol type=\"1\">\r\n<li><p>(CS)=(内存单元地址+2)</p></li>\r\n<li><p>(IP)=(内存单元地址)</p>\r\n<p>mov ax, 0123H<br>\r\nmov ds:[0], ax;偏移地址<br>\r\nmov word ptr ds:[2], 0;段地址<br>\r\njmp dword ptr ds:[0]<br>\r\n;执行后，<br>\r\n;(CS)=0<br>\r\n;(IP)=0123H<br>\r\n;CS:IP 指向 0000:0123。</p></li>\r\n</ol>\r\n<h3 id=\"jcxz指令和loop指令\">4、jcxz指令和loop指令</h3>\r\n<p><strong>jcxz指令</strong></p>\r\n<p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，</p>\r\n<p>在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p>\r\n<p>指令格式：<code>jcxz 标号</code>（如果(cx)=0，则转移到标号处执行。）</p>\r\n<p>当(cx) = 0时，(IP) = (IP) + 8位位移</p>\r\n<ul>\r\n<li>8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；</li>\r\n<li>8位位移的范围为-128~127，用补码表示；</li>\r\n<li>8位位移由编译程序在编译时算出。</li>\r\n</ul>\r\n<p>当(cx)!=0时，什么也不做（程序向下执行）</p>\r\n<p><strong>loop指令</strong></p>\r\n<p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。</p>\r\n<p>对IP的修改范围都为-128~127。</p>\r\n<p>指令格式：<code>loop 标号</code> ((cx) = (cx) - 1，如果(cx) ≠\r\n0，转移到标号处执行)。</p>\r\n<ol start=\"110\" type=\"i\">\r\n<li>= (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。</li>\r\n</ol>\r\n<ul>\r\n<li>8位位移 = 标号处的地址 - loop指令后的第一个字节的地址；</li>\r\n<li>8位位移的范围为-128~127，用补码表示；</li>\r\n<li>8位位移由编译程序在编译时算出。</li>\r\n</ul>\r\n<p>如果（cx）= 0，什么也不做（程序向下执行）。</p>\r\n<h1 id=\"九call和ret指令\">九、call和ret指令</h1>\r\n<hr>\r\n<p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p>\r\n<h2 id=\"ret-和-retf\">1、ret 和 retf</h2>\r\n<ul>\r\n<li><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p></li>\r\n<li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</p></li>\r\n</ul>\r\n<p>CPU执行ret指令时，相当于进行： <code>pop IP</code>：</p>\r\n<p>（1）(IP) = ( (ss) * 16 + (sp) )</p>\r\n<p>（2）(sp) = (sp) + 2</p>\r\n<p>CPU执行retf指令时，相当于进行：<code>pop IP, pop CS</code>：</p>\r\n<p>（1）(IP) = ( (ss) * 16 + (sp) )</p>\r\n<p>（2）(sp) = (sp) + 2</p>\r\n<p>（3）(CS) = ( (ss) * 16 + (sp) )</p>\r\n<p>（4）(sp) = (sp) + 2</p>\r\n<pre><code>assume cs:code \r\nstack seqment\r\n    db 16 dup (0)\r\nstack ends \r\n\r\ncode segment\r\n        mov ax, 4c00h\r\n        int 21h \r\n start: mov ax, stack \r\n        mov ss, ax\r\n        mov sp, 16\r\n        mov ax, 0\r\n        push ax ;ax入栈\r\n        mov bx, 0\r\n        ret ;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf\r\ncode ends\r\nend start</code></pre>\r\n<h2 id=\"call-指令\">2、call 指令</h2>\r\n<p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p>\r\n<p>（1）将当前的 IP 或 CS和IP 压入栈中；</p>\r\n<p>（2）转移（jmp）。</p>\r\n<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp\r\n指令的原理相同。</p>\r\n<p><code>call 标号</code>（近转移）</p>\r\n<p>CPU执行此种格式的call指令时，相当于进行 <code>push IP</code>\r\n<code>jmp near ptr 标号</code></p>\r\n<p><code>call far ptr 标号</code>（段间转移）</p>\r\n<p>CPU执行此种格式的call指令时，相当于进行：<code>push CS，push IP</code>\r\n<code>jmp far ptr 标号</code></p>\r\n<p><code>call 16位寄存器</code></p>\r\n<p>CPU执行此种格式的call指令时，相当于进行： <code>push IP</code>\r\n<code>jmp 16位寄存器</code></p>\r\n<p><code>call word ptr 内存单元地址</code></p>\r\n<p>CPU执行此种格式的call指令时，相当于进行：<code>push IP</code>\r\n<code>jmp word ptr 内存单元地址</code></p>\r\n<pre><code>mov sp, 10h\r\nmov ax, 0123h\r\nmov ds:[0], ax\r\ncall word ptr ds:[0]\r\n;执行后，(IP)=0123H，(sp)=0EH</code></pre>\r\n<p><code>call dword ptr 内存单元地址</code></p>\r\n<p>CPU执行此种格式的call指令时，相当于进行：<code>push CS</code>\r\n<code>push IP</code> <code>jmp dword ptr 内存单元地址</code></p>\r\n<pre><code>mov sp, 10h\r\nmov ax, 0123h\r\nmov ds:[0], ax\r\nmov word ptr ds:[2], 0\r\ncall dword ptr ds:[0]\r\n;执行后，(CS)=0，(IP)=0123H，(sp)=0CH</code></pre>\r\n<h2 id=\"call-和-ret-的配合使用\">3、call 和 ret 的配合使用</h2>\r\n<p>分析下面程序</p>\r\n<pre><code>assume cs:code\r\ncode segment\r\nstart:  mov ax,1\r\n        mov cx,3\r\n        call s ;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp\r\n        \r\n        mov bx,ax   ;（4）IP重新指向这里  bx = 8\r\n        mov ax,4c00h\r\n        int 21h\r\n     s: add ax,ax\r\n        loop s;（2）循环3次ax = 8\r\n        ret;（3）return : pop IP\r\ncode ends\r\nend start</code></pre>\r\n<p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计</p>\r\n<p>编写子程序</p>\r\n<h1 id=\"十标志寄存器\">十、标志寄存器</h1>\r\n<hr>\r\n<h2 id=\"标志寄存器\">1、标志寄存器</h2>\r\n<p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。</p>\r\n<p>（1）用来存储相关指令的某些执行结果；</p>\r\n<p>（2）用来为CPU执行相关指令提供行为依据；</p>\r\n<p>（3）用来控制CPU的相关工作方式。</p>\r\n<p>这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。</p>\r\n<p>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program\r\nStatus Word）</p>\r\n<p>flag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。</p>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190322182130199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令</p>\r\n<h3 id=\"零标志位-zf\">1、零标志位 (ZF)</h3>\r\n<p>零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。</p>\r\n<p>如果结果为0，那么zf = 1(表示结果是0)；如果结果不为0，那么zf = 0。</p>\r\n<pre><code>mov ax, 1\r\nsub ax, 1 ;执行后，结果为0，则zf = 1\r\n\r\nmov ax, 2\r\nsub ax, 1 ;执行后，结果不为0，则zf = 0</code></pre>\r\n<h3 id=\"奇偶标志位-pf\">2、奇偶标志位 (PF)</h3>\r\n<p>奇偶标志位（Parity\r\nFlag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p>\r\n<p>如果1的个数为偶数，pf = 1，如果为奇数，那么pf = 0。</p>\r\n<pre><code>mov al, 1\r\nadd al, 10 ;执行后，结果为00001011B，其中有3（奇数）个1，则pf = 0；\r\n\r\nmov al, 1\r\nor al, 2  ;执行后，结果为00000011B，其中有2（偶数）个1，则pf = 1；</code></pre>\r\n<h3 id=\"符号标志位sf\">3、符号标志位(SF)</h3>\r\n<p>符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。</p>\r\n<p>如果结果为负，sf = 1；如果非负，sf = 0。</p>\r\n<p>计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。</p>\r\n<p><code>00000001B</code>，可以看作为无符号数1，或有符号数+1；<br>\r\n<code>10000001B</code>，可以看作为无符号数129，也可以看作有符号数-127。</p>\r\n<p>对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p>\r\n<p>CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算</p>\r\n<p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值</p>\r\n<pre><code>mov al, 10000001B \r\nadd al, 1   ;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；\r\n\r\n\r\nmov al, 10000001B\r\nadd al, 01111111B   ;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为非负</code></pre>\r\n<h3 id=\"进位标志位cf\">3、进位标志位(CF)</h3>\r\n<p>进位标志位(Carry\r\nFlag)。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190322222505568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\r\n97H - 98H 产生借位CF = 1 ==》 (al) = 197H - 98H = FFH</p>\r\n<h3 id=\"溢出标志位of\">4、溢出标志位(OF)</h3>\r\n<p>溢出标志位(Overflow\r\nFlag)。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</p>\r\n<p>如果发生溢出，OF = 1；如果没有，OF = 0。</p>\r\n<p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位</p>\r\n<p>CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。</p>\r\n<ul>\r\n<li><p>对于无符号数运算，CPU用CF位来记录是否产生了进位；</p></li>\r\n<li><p>对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。</p>\r\n<p>mov al, 98<br>\r\nadd al, 99 ;执行后将产生溢出。因为进行的\"有符号数\"运算是：（al）=（al）+\r\n99 = 98 + 99=197 = C5H 为-59的补码<br>\r\n;而结果197超出了机器所能表示的8位有符号数的范围：-128-127。<br>\r\n;add 指令执行后：无符号运算没有进位CF=0，有符号运算溢出OF=1<br>\r\n;当取出的数据C5H按无符号解析C5H = 197,\r\n当按有符号解析通过SP得知数据为负,即C5H为-59补码存储，</p>\r\n<p>mov al，0F0H ;F0H，为有符号数-16的补码 -Not(F0 - 1)<br>\r\nadd al，088H ;88H，为有符号数-120的补码 -Not(88- 1)<br>\r\n;执行后，将产生溢出。因为add al, 088H进行的有符号数运算结果是：（al）=\r\n-136<br>\r\n;而结果-136超出了机器所能表示的8位有符号数的范围：-128-127。<br>\r\n;add 指令执行后：无符号运算有进位CF=1，有符号运算溢出OF=1</p></li>\r\n</ul>\r\n<h2 id=\"adc指令和sbb指令\">2、adc指令和sbb指令</h2>\r\n<p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>\r\n<p>指令格式：<code>adc 操作对象1, 操作对象2</code></p>\r\n<p>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</p>\r\n<pre><code>mov ax, 2\r\nmov bx, 1\r\nsub bx, ax  ;无符号运算借位CF=1，有符号运算OF = 0\r\nadc ax, 1   ;执行后，（ax）= 4。adc执行时，相当于计算：(ax)+1+CF = 2+1+1 = 4。</code></pre>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20190323125737798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<pre><code>;计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。\r\n;将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。\r\nmov ax, 001EH \r\nmov bx, 0F000H \r\nadd bx, 1000H\r\nadc ax, 0020H</code></pre>\r\n<p><strong>sbb指令</strong></p>\r\n<p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p>\r\n<p>指令格式：<code>sbb 操作对象1, 操作对象2</code></p>\r\n<p>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</p>\r\n<pre><code>;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：\r\nmov bx, 1000H\r\nmov ax, 003EH\r\nsub bx, 2000H\r\nsbb ax, 0020H</code></pre>\r\n<h2 id=\"cmp指令\">3、cmp指令</h2>\r\n<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p>\r\n<p>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p>\r\n<p>cmp指令格式：<code>cmp 操作对象1，操作对象2</code></p>\r\n<p>例如：<br>\r\n指令<code>cmp ax, ax</code>，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>\r\n指令执行后：zf=1，pf=1，sf=0，cf=0，of=0。</p>\r\n<p>CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。</p>\r\n<p>cmp ax, bx</p>\r\n<p>无符号比较时</p>\r\n<p>(ax) = (bx)</p>\r\n<p>zf = 1</p>\r\n<p>(ax) ≠ (bx)</p>\r\n<p>zf = 0</p>\r\n<p>(ax) &lt; (bx)</p>\r\n<p>cf = 1</p>\r\n<p>(ax) ≥ (bx)</p>\r\n<p>cf = 0</p>\r\n<p>(ax) &gt; (bx)</p>\r\n<p>cf = 0 且 zf = 0</p>\r\n<p>(ax) ≤ (bx)</p>\r\n<p>cf = 1 且 zf = 1</p>\r\n<p>上面的表格可以正推也可以逆推</p>\r\n<p>如果用cmp来进行有符号数比较时<br>\r\nSF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。<br>\r\n但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。</p>\r\n<pre><code>mov ah, 08AH  ; -Not(8A-1) = -118  即当成有符号数时为-118\r\nmov bh, 070H  ; 有符号数时最高位为0为正数， 70H = 112\r\ncmp ah, bh    ;（ah）-（bh）实际得到的结果是1AH \r\n              ; 在逻辑上，运算所应该得到的结果是：（-118）- 112 = -230\r\n              ; sf记录实际结果的正负，所以sf=0</code></pre>\r\n<blockquote>\r\n<p><code>cmp ah, bh</code><br>\r\n（1）如果sf=1，而of=0 。\r\nof=0说明没有溢出，逻辑上真正结果的正负=实际结果的正负；\r\nsf=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）</p>\r\n<p>（2）如果sf=1，而of=1：\r\nof=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；\r\nsf=1，实际结果为负。<br>\r\n实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。\r\n这样，sf=1，of=1，说明了（ah）&gt;（bh）。</p>\r\n<p>（3）如果sf=0，而of=1。of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；sf=0，实际结果非负。而of=1说明有溢出，则结果非0，所以，实际结果为正。<br>\r\n实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，sf=0，of=1，说明了（ah）&lt;（bh）。<br>\r\n（4）如果sf=0，而of=0<br>\r\nof=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；sf=0，实际结果非负，所以逻辑上真正的结果非负，所以（ah）≥（bh）。</p>\r\n</blockquote>\r\n<h2 id=\"检测比较结果的条件转移指令\">4、检测比较结果的条件转移指令</h2>\r\n<p>可以根据某种条件，决定是否修改IP的指令</p>\r\n<p>jcxz它可以检测cx中的数值，如果（cx）=0，就修改IP，否则什么也不做。</p>\r\n<p>所有条件转移指令的转移位移都是[-128，127]。</p>\r\n<p>多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP</p>\r\n<p>这些条件转移指令通常都和cmp相配合使用,它们所检测的标志位，都是cmp指令进行无符号数比较的时记录比较结果的标志位</p>\r\n<p>根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）</p>\r\n<p>指令</p>\r\n<p>含义</p>\r\n<p>检测的相关标志位</p>\r\n<p>je</p>\r\n<p>等于则转移</p>\r\n<p>zf = 1</p>\r\n<p>jne</p>\r\n<p>不等于则转移</p>\r\n<p>zf = 0</p>\r\n<p>jb</p>\r\n<p>低于则转移</p>\r\n<p>cf = 1</p>\r\n<p>jnb</p>\r\n<p>不低于则转移</p>\r\n<p>cf = 0</p>\r\n<p>ja</p>\r\n<p>高于则转移</p>\r\n<p>cf = 0 且 zf = 0</p>\r\n<p>jna</p>\r\n<p>不高于则转移</p>\r\n<p>cf = 1 且 zf = 1</p>\r\n<p>j：jump，e：equal，b：below，a：above，n：not</p>\r\n<pre><code>;编程，统计data段中数值为8的字节的个数，用ax保存统计结果。\r\nmov ax, data \r\nmov ds, ax \r\nmov bx, 0   ;ds:bx指向第一个字节\r\nmov ax, 0   ;初始化累加器mov cx，8\r\n\r\ns:\r\n    cmp byte ptr [bx], 8   ;和8进行比较\r\n    jne next  ;如果不相等转到next，继续循环\r\n    inc ax  ;如果相等就将计数值加1\r\nnext:\r\n    inc bx\r\n    loop s ;程序执行后：（ax）=3</code></pre>\r\n<h2 id=\"df标志和串传送指令\">5、DF标志和串传送指令</h2>\r\n<p>方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p>\r\n<ul>\r\n<li>df = 0每次操作后si、di递增；</li>\r\n<li>df = 1每次操作后si、di递减。</li>\r\n</ul>\r\n<p>格式：<code>movsb</code><br>\r\n功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减</p>\r\n<p>格式：<code>movsw</code><br>\r\n功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。</p>\r\n<p>格式：<code>rep movsb</code><br>\r\nmovsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，<br>\r\n功能：rep的作用是根据cx的值，重复执行后面的串传送指令</p>\r\n<p>8086CPU提供下面两条指令对df位进行设置。</p>\r\n<ul>\r\n<li><p><code>cld</code>指令：将标志寄存器的df位置0</p></li>\r\n<li><p><code>std</code>指令：将标志寄存器的df位置1</p>\r\n<p>;将data段中的第一个字符串复制到它后面的空间中。<br>\r\ndata segment<br>\r\ndb 'Welcome to masm!'<br>\r\ndb 16 dup (0)<br>\r\ndata ends</p>\r\n<p>mov ax, data<br>\r\nmov ds, ax<br>\r\nmov si, 0 ;ds:si 指向data:0<br>\r\nmov es, ax<br>\r\nmov di, 16 ;es:di指向data:0010</p>\r\n<p>mov cx, 16 ;（cx）=16，rep循环16次<br>\r\ncld ;设置df=0，正向传送<br>\r\nrep movsb</p></li>\r\n</ul>\r\n<h2 id=\"pushf和popf\">6、pushf和popf</h2>\r\n<p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中</p>\r\n<p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p>\r\n<h1 id=\"十一内中断\">十一、内中断</h1>\r\n<h2 id=\"内中断的产生\">1、内中断的产生</h2>\r\n<p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</p>\r\n<p>中断信息可以来自CPU的内部和外部（内中断，外中断）</p>\r\n<p>内中断：当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部</p>\r\n<p>8086CPU的内中断（下面四种情况将产生中断信息）</p>\r\n<ul>\r\n<li>除法错误，比如，执行div指令产生的除法溢出；</li>\r\n<li>单步执行；</li>\r\n<li>执行 into指令；</li>\r\n<li>执行 int指令。</li>\r\n</ul>\r\n<p>中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源（中断源）</p>\r\n<p>上述的4种中断源，在8086CPU中的中断类型码如下。</p>\r\n<ul>\r\n<li>除法错误：0</li>\r\n<li>单步执行：1</li>\r\n<li>执行into指令：4</li>\r\n<li>执行int指令，该指令的格式为int\r\nn，指令中的n为字节型立即数，是提供给CPU的中断类型码。</li>\r\n</ul>\r\n<h2 id=\"中断处理程序中断向量表中断过程\">2、中断处理程序、中断向量表、中断过程</h2>\r\n<p><strong>中断处理程序</strong></p>\r\n<p>用来处理中断信息的程序被称为中断处理程序。</p>\r\n<p>根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序</p>\r\n<p><strong>中断向量表</strong></p>\r\n<p>中断向量就是中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表</p>\r\n<p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址<br>\r\n<img src=\"https://img-blog.csdnimg.cn/20190323182525601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<p><strong>中断过程</strong></p>\r\n<p>中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP</p>\r\n<p>简要描述如下</p>\r\n<ol type=\"1\">\r\n<li>取得中断类型码N；</li>\r\n<li>pushf</li>\r\n<li>TF=0，IF=0 （为什么这样参考单步中断）</li>\r\n<li>push CS , push IP</li>\r\n<li>（IP）=（N * 4），（CS）=（N * 4 + 2）</li>\r\n</ol>\r\n<p>硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。</p>\r\n<h2 id=\"iret指令\">3、iret指令</h2>\r\n<p>CPU随时都可能执行中断处理程序，中断处理程序必须一直存储在内存某段空间之中<br>\r\n而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p>\r\n<p>中断处理程序的常规编写步骤：</p>\r\n<ol type=\"1\">\r\n<li>保存用到的寄存器；</li>\r\n<li>处理中断；</li>\r\n<li>恢复用到的寄存器；</li>\r\n<li>用<code>iret</code>指令返回。</li>\r\n</ol>\r\n<p>iret 指令描述为：<code>pop IP</code> <code>pop CS</code>\r\n<code>popf</code></p>\r\n<p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序</p>\r\n<h2 id=\"除法错误中断的处理\">4、除法错误中断的处理</h2>\r\n<pre><code>mov ax, 1000h \r\nmov bh, 1\r\ndiv bh ;除法溢出错误</code></pre>\r\n<p>1、当CPU执行div\r\nbh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，</p>\r\n<p>2、CPU执行0号中断处理程序</p>\r\n<p>3、系统中的0号中断处理程序的功能：显示提示信息“Divide\r\noverflow”后，返回到操作系统中。</p>\r\n<p><strong>编程实验</strong></p>\r\n<p>编程：编写0号中断处理程序do0，当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。</p>\r\n<p>1、0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，可以将中断处理程序do0传送到内存0000:0200处。</p>\r\n<p>2、中断处理程序do0放到<code>0000:0200</code>,再将其地址登记在中断向量表对应表项</p>\r\n<ul>\r\n<li><p>0号表项的地址<code>0:0</code>。<code>0:0</code>字单元存放偏移地址，<code>0:2</code>字单元存放段地址</p></li>\r\n<li><p>将do0的段地址0存放在<code>0000:0002</code>字单元中，将偏移地址200H存放在<code>0000:0000</code>字单元</p>\r\n<p>assume cs:code</p>\r\n<p>code segment<br>\r\nstart:<br>\r\nmov ax, cs<br>\r\nmov ds, ax<br>\r\nmov si, offset do0 ;设置ds:si指向源地址<br>\r\nmov ax, 0<br>\r\nmov es, ax<br>\r\nmov di, 200h ;设置es:di指向目的地址0000:0200<br>\r\nmov cx, offset do0end - offset do0 ;设置cx为传输长度\r\n编译时给出do0部分代码长度<br>\r\ncld ;设置传输方向为正<br>\r\nrep movsb ;将do0的代码送入0:200处</p>\r\n<pre><code>    mov ax, 0               ;设置中断向量表\r\n    mov es, ax\r\n    mov word ptr es:[0*4], 200h\r\n    mov word ptr es:[0*4+2], 0\r\n\r\n    mov ax,4c00h\r\n    int 21h</code></pre>\r\n<p>;do0程序的主要任务是显示字符串<br>\r\ndo0: jmp short do0 start<br>\r\ndb \"overflow!\"</p>\r\n<p>do0start:<br>\r\nmov ax, cs<br>\r\nmov ds, ax<br>\r\nmov si, 202h ;设置ds:si指向字符串</p>\r\n<pre><code>    mov ax, 0b800h\r\n    mov es, ax\r\n    mov di, 12*160+36*2     ;设置es:di指向显存空间的中间位置\r\n\r\n    mov cx, 9               ;设置cx为字符串长度\r\ns:  mov al, [si]\r\n    mov es:[di], al\r\n    inc si\r\n    add di, 1\r\n    mov al, 02h             ;设置颜色\r\n    mov es:[di], al        \r\n    add di, 1\r\n    loop s\r\n\r\n    mov ax, 4c00h\r\n    int 21h</code></pre>\r\n<p>do0end: nop</p>\r\n<p>code ends<br>\r\nend start</p></li>\r\n</ul>\r\n<h2 id=\"单步中断\">5、单步中断</h2>\r\n<p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1</p>\r\n<p>Debug是如何利用CPU所提供的单步中断的功能进行调试？如使用t命令查看寄存器状态</p>\r\n<p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令</p>\r\n<p>在使用t命令执行指令时，Debug将TF设置为1，在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。</p>\r\n<p>在进入中断处理程序之前，设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断</p>\r\n<h2 id=\"int指令\">6、int指令</h2>\r\n<p>int指令的格式为：<code>int n</code>\r\n，n为中断类型码，它的功能是引发中断过程。</p>\r\n<p>CPU执行int n指令，相当于引发一个n号中断的中断过程</p>\r\n<p>在程序中使用int指令调用任何一个中断的中断处理程序(中断例程)</p>\r\n<p><strong>编写供应用程序调用的中断例程</strong></p>\r\n<p><strong>实验1</strong></p>\r\n<pre><code>;求2 * 3456^2\r\nassume cs:code\r\n\r\ncode segment\r\n\r\nstart: \r\n     mov ax, 3456 ;(ax)=3456\r\n     int 7ch  ; 调用中断7ch的中断例程，计算ax中的数据的平方\r\n     add ax, ax  \r\n     adc dx, dx  ;存放结果，将结果乘以2\r\n\r\n     mov ax,4c00h\r\n     int 21h\r\ncode ends\r\nend start \r\n\r\n\r\n;编程：安装中断7ch的中断例程\r\n;功能：求一word型数据的平方。\r\n;参数：(ax) = 要计算的数据。\r\n;返回值：dx、ax中存放结果的高16位和低16位。\r\n\r\nassume cs:code\r\n\r\ncode segment\r\nstart:\r\n        mov ax,cs\r\n        mov ds,ax\r\n        mov si,offset sqr                   ;设置ds:si指向源地址\r\n        mov ax,0\r\n        mov es,ax\r\n        mov di,200h                         ;设置es:di指向目的地址\r\n        mov cx,offset sqrend - offset sqr   ;设置cx为传输长度\r\n        cld                                 ;设置传输方向为正\r\n        rep movsb\r\n\r\n        mov ax,0\r\n        mov es,ax\r\n        mov word ptr es:[7ch*4], 200h\r\n        mov word ptr es:[7ch*4+2], 0\r\n\r\n        mov ax,4c00h\r\n        int 21h\r\n\r\n  sqr:  \r\n        mul ax\r\n        iret  ;CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈\r\n              ;在执行完中断例程后，应该用iret 指令恢复int 7ch执行前的标志寄存器和CS、IP的\r\nsqrend: nop\r\n\r\ncode ends\r\nend start</code></pre>\r\n<p><strong>实验2</strong></p>\r\n<pre><code>;功能：将一个全是字母，以0结尾的字符串，转化为大写。\r\n;参数：ds:si指向字符串的首地址。\r\n;应用举例：将data段中的字符串转化为大写。\r\nassume cs:code\r\n\r\ndata segment\r\n    db 'conversation',0\r\ndata ends\r\n\r\ncode segment\r\nstart:  mov ax, data\r\n        mov ds, ax\r\n        mov si, 0\r\n        int 7ch\r\n        \r\n        mov ax,4c00h\r\n        int 21h\r\ncode ends\r\nend start   </code></pre>\r\n<p>​<br>\r\n​assume cs:code<br>\r\n​code segment<br>\r\n​<br>\r\nstart:<br>\r\nmov ax,cs<br>\r\nmov ds,ax<br>\r\nmov si,offset capital<br>\r\nmov ax,0<br>\r\nmov es,ax<br>\r\nmov di,200h<br>\r\nmov cx,offset capitalend - offset capital<br>\r\ncld<br>\r\nrep movsb</p>\r\n<pre><code>        mov ax,0\r\n        mov es,ax\r\n        mov word ptr es:[7ch*4],200h\r\n        mov word ptr es:[7ch*4+2],0\r\n\r\n        mov ax,4c00h\r\n        int 21h\r\n\r\ncapital:\r\n        push cx\r\n        push si\r\n        \r\nchange: \r\n        mov cl,[si]\r\n        mov ch,0\r\n        jcxz ok\r\n        and byte ptr [si],11011111b\r\n        inc si\r\n        jmp short change\r\nok: \r\n        pop si\r\n        pop cx\r\n        iret\r\n        \r\ncapitalend:nop\r\n\r\ncode ends\r\n\r\nend start</code></pre>\r\n<p>​</p>\r\n<h2 id=\"bios和dos所提供的中断例程\">7、BIOS和DOS所提供的中断例程</h2>\r\n<p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统）</p>\r\n<p>BIOS中主要包含以下几部分内容</p>\r\n<ul>\r\n<li>硬件系统的检测和初始化程序；</li>\r\n<li>外部中断和内部中断的中断例程；</li>\r\n<li>用于对硬件设备进行I/O操作的中断例程；</li>\r\n<li>其他和硬件系统相关的中断例程。</li>\r\n</ul>\r\n<p>程序员在编程的时候，可以用int\r\n指令直接调用BIOS和DOS系统提供的中断例程，来完成某些工作。<br>\r\n和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\r\n<p><strong>BIOS和DOS中断例程的安装过程</strong></p>\r\n<p>BIOS和DOS提供的中断例程是如何安装到内存中的呢？</p>\r\n<p>1、开机后，CPU一加电，初始化（CS）= 0FFFFH，（IP）=\r\n0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p>\r\n<p>2、初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。<br>\r\n注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</p>\r\n<p>3、硬件系统检测和初始化完成后，调用int\r\n19h进行操作系统的引导。从此将计算机交由操作系统控制。</p>\r\n<p>4、DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p>\r\n<p><strong>BIOS中断例程应用</strong></p>\r\n<p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。</p>\r\n<p>BIOS和DOS提供的中断例程，都用 ah 来传递内部子程序的编号。</p>\r\n<p>编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的“al。</p>\r\n<pre><code>assume cs:code \r\n\r\ncode segment\r\n;int 10h中断例程的\"设置光标位置\"功能\r\nmov ah, 2;设置光标调用第10h号中断例程的2号子程序，功能为设置光标位置(可以提供光标所在的行号、列号和页号作为参数)\r\n\r\n;设置光标到第0页，第5行，第12列\r\nmov bh, 0；第0页\r\nmov dh, 5；dh中放行号\r\nmov dl, 12；dl中放列号\r\nint 10h\r\n\r\n;int10h中断例程的\"在光标位置显示字符\"功能。\r\nmov ah，9 ;调用第10h号中断例程的9号子程序，功能为在光标位置显示字符\r\n;提供要显示的字符、颜色属性、页号、字符重复个数作为参数\r\nmov al，'a'  ;字符\r\nmov b1，11001010b  ;颜色属性\r\nmov bh，0  ;第0页\r\nmov cx，3  ;字符重复个数\r\nint 10h\r\n\r\ncode ends \r\nend</code></pre>\r\n<p>bh中页号的含义：内存地址空间中，<code>B8000H~BFFFFH</code>共32kB的空间，为80*25彩色字符模式的显示缓冲区。<br>\r\n一屏的内容在显示缓冲区中共占4000个字节。显示缓冲区分为8页，每页4KB（约4000B），显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</p>\r\n<p><strong>DOS中断例程应用</strong><br>\r\n<code>int 21h</code>中断例程是DOS提供的中断例程，<code>4ch</code>号功能，即程序返回功能</p>\r\n<pre><code>mov ah, 4ch ;调用第21h号中断例程的4ch号子程序，功能为程序返回,可以提供返回值作为参数\r\nmov al, 0 ;返回值\r\nint 21h</code></pre>\r\n<p>编程：在屏幕的5行12列显示字符串“Welcome to masm！”。</p>\r\n<pre><code>assume cs:code \r\n \r\ndata segment \r\n    db  'Welcome to masm',  '$'     ;“$”本身并不显示，只起到边界的作用\r\ndata ends \r\n\r\ncode segment\r\nstart:  mov ah, 2 ;10号中断设置光标位置功能\r\n        mov bh, 0 ;第0页\r\n        mov dh, 5；dh中放行号\r\n        mov dl, 12 ;dl中放列号\r\n        int 10h \r\n        \r\n        mov ax, data \r\n        mov ds, ax \r\n        mov dx, 0 ;ds:dx指向字符串的首地址data:0  （参数）\r\n        mov ah, 9 ;调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数\r\n        int 21h \r\n        \r\n        mov ax, 4c00h ;21号中断程序返回功能\r\n        int 21h \r\ncode ends\r\nend start</code></pre>\r\n<h1 id=\"十二端口\">十二、端口</h1>\r\n<p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。</p>\r\n<ul>\r\n<li>各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；</li>\r\n<li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li>\r\n<li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li>\r\n</ul>\r\n<p>在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，<br>\r\n但是它们在以下两点上相同。</p>\r\n<ul>\r\n<li>都和CPU的总线相连，这种连接是通过它们所在的芯片进行的；</li>\r\n<li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li>\r\n</ul>\r\n<p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。<br>\r\n每一个端口在地址空间中都有一个地址。在访问端口的时候，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，</p>\r\n<p>CPU可以直接读写以下3个地方的数据。</p>\r\n<ul>\r\n<li>CPU内部的寄存器；</li>\r\n<li>内存单元；</li>\r\n<li>端口。</li>\r\n</ul>\r\n<h2 id=\"端口的读写\">1、端口的读写</h2>\r\n<p>端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为<code>0-65535</code>。</p>\r\n<p>端口的读写指令只有两条：<code>in</code>和<code>out</code>，分别用于从端口读取数据和往端口写入数据。</p>\r\n<p>在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。</p>\r\n<pre><code>;对0~255以内的端口进行读写时：\r\nin al, 20h  ;从20h端口读入一个字节\r\nout 20h, al  ;往20h端口写入一个字节\r\n\r\n;对256~65535的端口进行读写时，端口号放在dx中：\r\nmov dx, 3f8h  ;将端口号3f8h送入dx\r\nin al, dx  ;从3f8h端口读入一个字节\r\nout dx, al ;向3f8h端口写入一个字节</code></pre>\r\n<h2 id=\"cmos-ram芯片\">2、CMOS RAM芯片</h2>\r\n<p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下</p>\r\n<ul>\r\n<li>包含一个实时钟和一个有128个存储单元的RAM存储器</li>\r\n<li>该芯片靠电池供电。关机后内部的实时钟正常工作，RAM中的信息不丢失</li>\r\n<li>128个字节的RAM中，内部实时钟占用<code>0~0dh</code>单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS\r\nRAM中的系统信息。</li>\r\n<li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS\r\nRAM</li>\r\n<li>70h为地址端口，存放要访问的CMOS\r\nRAM单元的地址；71h为数据端口，存放从选定的CMOS\r\nRAM单元中读取的数据，或要写入到其中的数据。<br>\r\n可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：<br>\r\n①将2送入端口70h；<br>\r\n②从端口71h读出2号单元的内容。</li>\r\n</ul>\r\n<p><strong>CMOS RAM中存储的时间信息</strong></p>\r\n<p>在CMOS\r\nRAM中，存放着当前的时间：年、月、日、时、分、秒。长度都为1个字节，<br>\r\n存放单元为：</p>\r\n<p>9</p>\r\n<p>8</p>\r\n<p>7</p>\r\n<p>6</p>\r\n<p>5</p>\r\n<p>4</p>\r\n<p>3</p>\r\n<p>2</p>\r\n<p>1</p>\r\n<p>0</p>\r\n<p>年</p>\r\n<p>月</p>\r\n<p>日</p>\r\n<p>时</p>\r\n<p>分</p>\r\n<p>秒</p>\r\n<p>BCD码是以4位二进制数表示十进制数码的编码方法 4 == 0100B</p>\r\n<p>一个字节可表示两个BCD码。则CMOS\r\nRAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。</p>\r\n<pre><code>;编程，在屏幕中间显示当前的月份。\r\nassume cs:code\r\ncode segment \r\nstart:  mov al，8 ;从CMOS RAM的8号单元读出当前月份的BCD码。\r\n        out 70h，al \r\n        in al, 71h ;从数据端口71h中取得指定单元中的数据：\r\n        \r\n        mov ah, al ;al中为从CMOS RAM的8号单元中读出的数据\r\n        mov cl, 4\r\n        shr ah, cl ;ah中为月份的十位数码值,左移四位空出四位\r\n        and al, 00001111b ;al中为月份的个位数码值\r\n        \r\n        add ah, 30h ;BCD码值+30h=十进制数对应的ASCII\r\n        add al, 30h \r\n        \r\n        mov bx, 0b800h \r\n        mov es, bx \r\n        mov byte ptr es:[160*12+40*2], ah ;显示月份的十位数码\r\n        mov byte ptr es:[160*12+40*2+2], al ;接着显示月份的个位数码\r\n        \r\n        mov ax，4c00h\r\n        int 21h\r\ncode ends\r\nend start</code></pre>\r\n<h2 id=\"shl和shr指令\">3、shl和shr指令</h2>\r\n<p>shl和shr是逻辑移位指令</p>\r\n<p>shl是逻辑左移指令，它的功能为：</p>\r\n<ol type=\"1\">\r\n<li>将一个寄存器或内存单元中的数据向左移位；</li>\r\n<li>将最后移出的一位写入CF中；</li>\r\n<li>最低位用0补充。</li>\r\n</ol>\r\n<p>shr是逻辑右移指令，同理</p>\r\n<pre><code>mov al, 01001000b \r\nshl al, 1 ;将a1中的数据左移一位执行后（al）=10010000b，CF=0。\r\n\r\nmov al, 01010001b \r\nmov cl, 3 ;如果移动位数大于1时，必须将移动位数放在cl中\r\nshl al, c1\r\n\r\nmov al, 10000001b \r\nshr al, 1  ;将al中的数据右移一位执行后（al）=01000000b，CF=1。</code></pre>\r\n<p>将X逻辑左移一位，相当于执行X=X*2。<br>\r\n将X逻辑右移一位，相当于执行X=X/2</p>\r\n<h1 id=\"十三外中断\">十三、外中断</h1>\r\n<h2 id=\"外中断\">1、外中断</h2>\r\n<p>CPU在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出（I/O能力）</p>\r\n<p>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问</p>\r\n<p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；<br>\r\nCPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。<br>\r\nCPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</p>\r\n<p>即：CPU通过端口和外部设备进行联系</p>\r\n<p>当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p>\r\n<p><strong>PC系统中，外中断源有两类</strong></p>\r\n<p>1、可屏蔽中断</p>\r\n<p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。<br>\r\n当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。</p>\r\n<p>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。</p>\r\n<p>中断过程中将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。<br>\r\n如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。</p>\r\n<p>8086CPU提供的设置IF的指令：<code>sti</code>，设置IF=1；<code>cli</code>，设置IF=0。</p>\r\n<p>2、不可屏蔽中断</p>\r\n<p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</p>\r\n<p>对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：①标志寄存器入栈，IF=0，TF=0；②CS、IP入栈；③（IP）=（8），（CS）=（0AH）。</p>\r\n<p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。</p>\r\n<h2 id=\"pc机键盘的处理过程\">2、PC机键盘的处理过程</h2>\r\n<p>键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60h</code>。松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。</p>\r\n<p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p>\r\n<p>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1<br>\r\n即：断码 = 通码 + 80h。比如，g键的通码为22h，断码为a2h</p>\r\n<p>键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int\r\n9中断例程。</p>\r\n<p><img src=\"https://img-blog.csdnimg.cn/2019032416380958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NjU0MTI3,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\r\n<p>BIOS提供了int\r\n9中断例程，用来进行基本的键盘输入处理，主要的工作如下：<br>\r\n（1）读出60h端口中的扫描码；<br>\r\n（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区；\r\n如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节写入内存中存储状态字节的单元；<br>\r\n（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</p>\r\n<p>BIOS键盘缓冲区可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p>\r\n<p><code>0040:17</code>单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。</p>\r\n<p>0</p>\r\n<p>右shift状态</p>\r\n<p>置1表示按下右shift键</p>\r\n<p>1</p>\r\n<p>左shift状态</p>\r\n<p>置1表示按下左shift键</p>\r\n<p>2</p>\r\n<p>Ctrl状态</p>\r\n<p>置1表示按下Ctrl键</p>\r\n<p>3</p>\r\n<p>Alt状态</p>\r\n<p>置1表示按下Alt键</p>\r\n<p>4</p>\r\n<p>ScrollLock状态</p>\r\n<p>置1表示Scroll指示灯亮</p>\r\n<p>5</p>\r\n<p>NumLock状态</p>\r\n<p>置1表示小键盘输入的是数字</p>\r\n<p>6</p>\r\n<p>CapsLock状态</p>\r\n<p>置1表示输入大写字母</p>\r\n<p>7</p>\r\n<p>Insert状态</p>\r\n<p>置1表示处于删除态</p>\r\n<p><strong>编写int 9中断例程</strong></p>\r\n<pre><code>;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下'Esc'键后，改变显示的颜色。\r\n\r\n;完整功能代码：\r\n\r\nassume cs:code\r\n\r\nstack segment\r\n    db 128 dup (0)\r\nstack ends\r\n\r\ndata segment\r\n    dw 0,0\r\ndata ends\r\n\r\ncode segment\r\nstart:  \r\n    mov ax,stack\r\n    mov ss,ax\r\n    mov sp,128\r\n    mov ax,data\r\n    mov ds,ax\r\n    mov ax,0\r\n    mov es,ax\r\n\r\n    push es:[9*4]\r\n    pop ds:[0]\r\n    push es:[9*4+2]\r\n    pop ds:[2]      ;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中\r\n\r\n    mov word ptr es:[9*4], offset int9\r\n    mov es:[9*4+2], cs  ;在中断向量表中设置新的int 9中断例程的入口地址\r\n\r\n;显示字符串\r\n    mov ax, 0b800h\r\n    mov es, ax\r\n    mov ah, 'a'\r\ns:  \r\n    mov  es:[160*12+40*2], ah\r\n    call delay\r\n    inc ah\r\n    cmp ah, 'z'\r\n    jna s\r\n    mov ax,0\r\n    mov es,ax\r\n\r\n    push ds:[0]\r\n    pop es:[9*4]\r\n    push ds;[2]\r\n    pop es;[9*4+2]      ;将中断向量表中int 9中断例程的入口恢复为原来的地址\r\n\r\n    mov ax,4c00h\r\n    int 21h\r\n\r\n;将循环延时的程序段写为一个子程序\r\ndelay:  \r\n    push ax \r\n    push dx\r\n    mov dx, 2000h  ;用两个16位寄存器来存放32位的循环次数\r\n    mov ax, 0\r\ns1:     \r\n    sub ax, 1\r\n    sbb dx, 0\r\n    cmp ax, 0\r\n    jne s1\r\n    cmp dx, 0\r\n    jne s1\r\n    pop dx\r\n    pop ax\r\n    ret\r\n\r\n;------以下为新的int 9中断例程--------------------\r\n\r\nint9:   \r\n    push ax\r\n    push bx\r\n    push es\r\n\r\n    in al, 60h;从端口60h读出键盘的输入\r\n\r\n    pushf ;标志寄存器入栈\r\n\r\n    pushf   \r\n    pop bx\r\n    and bh,11111100b\r\n    push bx\r\n    popf    ;TF=0,IF=0\r\n    \r\n    call dword ptr ds:[0]   ;对int指令进行模拟，调用原来的int 9中断例程\r\n\r\n    cmp al,1\r\n    jne int9ret\r\n\r\n    mov ax,0b800h\r\n    mov es,ax\r\n    inc byte ptr es:[160*12+40*2+1]  ;属性增加1，改变颜色\r\n\r\nint9ret:\r\n    pop es\r\n    pop bx\r\n    pop ax\r\n    iret\r\n\r\ncode ends\r\n\r\nend start</code></pre>\r\n<p>​</p>\r\n<p>CPU对外设输入的通常处理方法<br>\r\n（1）外设的输入送入端口；<br>\r\n（2）向CPU发出外中断（可屏蔽中断）信息；<br>\r\n（3）CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程；<br>\r\n（4）可在中断例程中实现对外设输入的处理。</p>\r\n<p>端口和中断机制，是CPU进行I/O的基础。</p>\r\n<h1 id=\"十四直接定址表\">十四、直接定址表</h1>\r\n<pre><code>assume cs:code\r\ncode segment\r\n         a : db 1,2,3,4,5,6,7,8  ;在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。\r\n         b : dw 0\r\nstart :mov si,offset a\r\n         mov bx,offset b\r\n         mov cx,8\r\n    s : mov al,cs:[si]\r\n         mov ah,0\r\n         add cs:[bx],ax\r\n         inc si\r\n         loop s\r\n         mov ax,4c00h\r\n         int 21h\r\ncode ends\r\nend start</code></pre>\r\n<p>​</p>\r\n<p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址</p>\r\n<p><strong>描述了单位长度的标号</strong></p>\r\n<pre><code>assume cs:code\r\ncode segment\r\n          a db 1,2,3,4,5,6,7,8 ;标号a、b后面没有\":\"，因此它们是可以同时描述内存地址和单元长度的标号。\r\n                               ;标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元\r\n          b dw 0               ;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。\r\nstart :  mov si,0\r\n          mov cx,8\r\n    s :   mov al,a[si]\r\n          mov ah,0\r\n          add b,ax\r\n          inc si\r\n          loop s\r\n          mov ax,4c00h\r\n          int 21h\r\ncode ends\r\nend start</code></pre>\r\n<p>​</p>\r\n<p>使用<strong>数据标号</strong>来描述存储数据的单元的地址和长度。</p>\r\n<pre><code>assume cs:code,ds:data ；用伪指令assume将标号所在的段和一个段寄存器联系起来(编译器需要)\r\ndata segment          \r\n          a db 1,2,3,4,5,6,7,8\r\n          b dw 0\r\ndata ends\r\ncode segment\r\nstart:  mov ax,data\r\n          mov ds,ax ;真正确定ds寄存器\r\n          mov si,0\r\n          mov cx,8\r\ns:       mov al,a[si] ;编译为：mov al,[si+0] 默认所访问单元的段地址在ds\r\n          mov ah,0\r\n          add b,ax ;编译为：add [8],ax\r\n          inc si\r\n          loop s\r\n          mov ax,4c00h\r\n          int 21h\r\ncode ends\r\nend start\r\n\r\n\r\ndata segment\r\n    a db 1,2,3,4,5,6,7,8\r\n    b dw 0\r\n    c dw a, b ;等价于c dw offset a, offset b\r\n    ;数据标号c处存储的两个字型数据为标号a、b 的偏移地址\r\ndata ends\r\n\r\ndata segment\r\n    a db 1,2,3,4,5,6,7,8\r\n    b dw 0\r\n    c dd a,b ;等价于c dw offset a, seg a, offset b, seg b\r\n    ;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址\r\ndata ends</code></pre>\r\n<p>​</p>\r\n<p>seg操作符，功能为取得某一标号的段地址</p>\r\n<p>建立一张表，表中依次存储字符“0”~“F”，我们可以通过数值0 ~\r\n15直接查找到对应的字符</p>\r\n<pre><code>assume cs:code\r\n\r\ncode segment\r\nstart:  \r\n        mov al,0eh\r\n\r\n        call showbyte\r\n\r\n        mov ax,4c00h\r\n        int 21h\r\n\r\n;子程序：\r\n;用al传送要显示的数据\r\n\r\nshowbyte:\r\n        jmp short show\r\n\r\n        table db '0123456789ABCDEF' ;字符表\r\n\r\nshow:   push bx\r\n        push es\r\n\r\n        mov ah,al\r\n        shr ah,1           \r\n        shr ah,1\r\n        shr ah,1\r\n        shr ah,1                ;右移4位，ah中得到高4位的值\r\n        and al,00001111b        ;al中为低4位的值\r\n\r\n        mov bl,ah\r\n        mov bh,0\r\n        mov ah,table[bx]        ;用高4位的值作为相对于table的偏移，取得对应的字符\r\n\r\n        mov bx,0b800h\r\n        mov es,bx\r\n        mov es:[160*12+40*2],ah\r\n\r\n        mov bl,al\r\n        mov bh,0\r\n        mov al,table[bx]        ;用低4位的值作为相对于table的偏移，取得对应的字符\r\n        \r\n        mov es:[160*12+40*2+2],al\r\n\r\n        pop es\r\n        pop bx\r\n        ret\r\n\r\ncode ends\r\nend start</code></pre>\r\n<p>​</p>\r\n<h1 id=\"十五-指令系统总结\">十五、 指令系统总结</h1>\r\n<p>我们对8086CPU的指令系统进行一下总结。读者若要详细了解8086指令系统中的各个指令的用，可以查看有关的指令手册。</p>\r\n<p>8086CPU提供以下几大类指令。</p>\r\n<ol type=\"1\">\r\n<li>数据传送指令<br>\r\n<code>mov、push、pop、pushf、popf、xchg</code>\r\n等都是数据传送指令，这些指令实现寄存器和内存、寄器和寄存器之间的单个数据传送。</li>\r\n<li>算术运算指令<br>\r\n<code>add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa</code>等都是算术运算指令，这些指令实现存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的<code>sf、zf、of、cf、pf、af</code>位。</li>\r\n<li>逻辑指令<br>\r\n<code>and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr</code>等都是逻辑指令。除了not指外，它们的执行结果都影响标志寄存器的相关标志位。</li>\r\n<li>转移指令<br>\r\n可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。<br>\r\n（1）无条件转移指令，比如，<code>jmp</code>；<br>\r\n（2）条件转移指令，比如，<code>jcxz、je、jb、ja、jnb、jna</code>等；<br>\r\n（3）循环指令，比如，<code>loop</code>；<br>\r\n（4）过程，比如，<code>call、ret、retf</code>；<br>\r\n（5）中断，比如，<code>int、iret</code>。</li>\r\n<li>处理机控制指令<br>\r\n对标志寄存器或其他处理机状态进行设置，<code>cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock</code>等都是处理机控制指令。</li>\r\n<li>串处理指令<br>\r\n对内存中的批量数据进行处理，<code>movsb、movsw、cmps、scas、lods、stos</code>等。若要使用这些指令方便地进行批量数据的处理，则需要和<code>rep、repe、repne</code>\r\n等前缀指令配合使用。</li>\r\n</ol>\r\n<hr>\r\n"}]