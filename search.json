[{"title":"c++ primer 第二章","url":"/posts/aa2834e7/","content":"<h1 id=\"第2章-变量和基本类型\">第2章 变量和基本类型</h1>\r\n<span id=\"more\"></span>\r\n<p><strong>2.1 基本内置类型</strong></p>\r\n<p><strong>2.1.1 算术类型</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>含义</th>\r\n<th>最小尺寸</th>\r\n<th>备注</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>char</td>\r\n<td>字符</td>\r\n<td>8位</td>\r\n<td>1B(8b)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>wchar_t</td>\r\n<td>宽字符</td>\r\n<td>16位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>char16_t</td>\r\n<td>Unicode字符</td>\r\n<td>16位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>char32_t</td>\r\n<td>Unicode字符</td>\r\n<td>32位</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>float</td>\r\n<td>单精度浮点数</td>\r\n<td>6位有效数字</td>\r\n<td>1个字(32b)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>double</td>\r\n<td>双精度浮点数</td>\r\n<td>10位有效数字</td>\r\n<td>2个字(64b)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>long double</td>\r\n<td>扩展精度浮点数</td>\r\n<td>10位有效数字</td>\r\n<td>4个字(128b)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>存储的基本单元：字，32b/64b。</p>\r\n<p>明确知晓数值不可能为负时，选用无符号类型。</p>\r\n<p>char 是否有符号并不确定，因此使用 signed char 或 unsigned char\r\n来指定是否有符号。</p>\r\n<p>整数运算用 int/long long。</p>\r\n<p>浮点数运算用 double。float 和 double 的计算代价相差无几。</p>\r\n<p><strong>2.1.2 类型转换</strong></p>\r\n<p>赋给无符号类型超出范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>\r\n<p>赋给带符号类型超出范围的值时，结果是未定义的。</p>\r\n<p>带符号数与无符号数做运算，会被转化为无符号数。</p>\r\n<p><strong>2.1.3 字面值常量</strong></p>\r\n<p><strong>整型和浮点型字面值</strong></p>\r\n<p>0 开头的整数是 8 进制，0x 开头的整数是十六进制。</p>\r\n<p>十进制字面值的类型是 int, long, long long\r\n中可以放下它的最小尺寸。</p>\r\n<p>八进制和十六进制字面值的类型是 int, long, long long, unsigned int,\r\nunsigned long, unsigned long long 中可以放下它的最小尺寸。</p>\r\n<p>浮点型字面值可以用小数或科学计数法表示，科学计数法中的指数部分用 E 或\r\ne 标识，默认 double：3.14, 0., 0e0, .001, 3.14E2。</p>\r\n<p><strong>字符和字符串字面值</strong></p>\r\n<p>单引号括起来的一个字符是 char 型字面值，双引号括起来的 0\r\n个或多个字符则构成字符串型字面值。</p>\r\n<p>字符串字面值的类型实际上是字符数组，编译器会向每个字符串结尾添加一个空字符（'\\0'），因此字符串字面值的实际长度要比它的内容多\r\n1。</p>\r\n<p>如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。因此字符串比较长时可以直接分行书写。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"A \"</span></span><br><span class=\"line\">\t\t<span class=\"string\">\"B\"</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\r\n<p><strong>转义序列</strong></p>\r\n<p>换行符：，横向制表符：，报警符：，纵向制表符：退格符：<strong>双引号：\"，</strong></p>\r\n<p><strong>反斜线：\\，单引号：'</strong>，<strong>问号：?</strong>，回车符：进纸符：述转义序列被当作一个字符使用。</p>\r\n<p>也可以使用泛化的转移序列，形式是  后跟 1~3 个八进制数字或 后跟 1\r\n个或多个十六进制数字。</p>\r\n<p>如果  后面跟着的八进制数字超过 3 个，只有前三个数字与\r\n 构成转义序列。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\<span class=\"number\">115</span>  <span class=\"comment\">//字符 M</span></span><br><span class=\"line\">\\x4d  <span class=\"comment\">//字符 M</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>指定字面值的类型</strong></p>\r\n<p>可以通过给字面值增加前缀和后缀来改变字面值的默认类型。</p>\r\n<p>字符和字符串字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>前缀</th>\r\n<th>含义</th>\r\n<th>类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>u</td>\r\n<td>Unicode 16字符</td>\r\n<td>char16_t</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>U</td>\r\n<td>Unicode 32字符</td>\r\n<td>char32_t</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>L</td>\r\n<td>宽字符</td>\r\n<td>wchar_t</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>u8</td>\r\n<td>UTF-8(仅用于字符串字面常量)</td>\r\n<td>char</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>整形字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>后缀</th>\r\n<th style=\"text-align: left;\">最小匹配类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>u or U</td>\r\n<td style=\"text-align: left;\">unsigned</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>l or L</td>\r\n<td style=\"text-align: left;\">long</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>ll or LL</td>\r\n<td style=\"text-align: left;\">long long</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>浮点型字面值</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>后缀</th>\r\n<th>类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>f or F</td>\r\n<td>double</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>l or L</td>\r\n<td>long double</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>12f 是错的，不能给整型字面值加 f 后缀，可以使用 12.f。</p>\r\n<p>用 LL 代替 ll 防止与 1 混淆。</p>\r\n<p><strong>2.2 变量</strong></p>\r\n<p><strong>2.2.1 变量定义</strong></p>\r\n<p><strong>初始化</strong></p>\r\n<p>可以在同一条定义语句中使用先定义的变量去初始化后定义的其他变量。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> price = <span class=\"number\">109.99</span>, discount = price * <span class=\"number\">0.6</span>;</span><br></pre></td></tr></table></figure>\r\n<p>初始化不是赋值，初始化是创建变量时赋予一个初始值，赋值是把对象的当前值<strong>擦除</strong>并用一个新值来替代。</p>\r\n<p><strong>列表初始化</strong></p>\r\n<p>四种初始化方式，其中使用花括号的方式叫做列表初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = {<span class=\"number\">0</span>};</span><br><span class=\"line\"><span class=\"type\">int</span> i{<span class=\"number\">0</span>};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">i</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>当用于内置类型的变量时，使用列表初始化且初始值存在信息丢失的风险，编译器会报错。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">double</span> ld = <span class=\"number\">3.14</span>; <span class=\"type\">int</span> a{ld}, b = {ld}; <span class=\"comment\">//错误，存在信息丢失的风险，转换未执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">c</span><span class=\"params\">(ld)</span>, d </span>= ld;  <span class=\"comment\">//正确</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>默认初始化</strong></p>\r\n<p>定义于任何函数之外的内置类型则被初始化为 0；</p>\r\n<p>定义于函数体内的内置类型的对象如果没有初始化，则其值<strong>未定义</strong>。</p>\r\n<p>类的对象如果没有显式地初始化，则其由类确定。</p>\r\n<p><strong>2.2.2 变量声明和定义的关系</strong></p>\r\n<p>声明：使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。规定了变量的类型和名字。</p>\r\n<p>定义：在声明的基础上，创建与名字关联的实体，即申请存储空间，还可能会为变量赋一个初始值。</p>\r\n<p>要声明一个变量加\r\nextern，声明变量不能赋值，任何包含了显式初始化的声明即成为定义。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> i;     <span class=\"comment\">// 声明 i</span></span><br><span class=\"line\"><span class=\"type\">int</span> i;            <span class=\"comment\">// 定义 i；</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> i = <span class=\"number\">1</span>; <span class=\"comment\">// 定义 i，初始化抵消了 extern 的作用。</span></span><br></pre></td></tr></table></figure>\r\n<p>变量只能被定义一次，但是可以多次声明。</p>\r\n<p>extern 定义的变量必须是全局的，这样才可能在其他文件中使用。</p>\r\n<p>如果要在多个文件中使用同一个变量，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p>\r\n<p>C++ 是静态类型语言，在编译阶段检查类型。</p>\r\n<p><strong>2.2.3 标识符</strong></p>\r\n<p>标识符组成：字母、数字、下划线。不能以数字开头。标识符的长度没有限制。</p>\r\n<p>用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。定义在函数体外的标识符不能以下划线开头。</p>\r\n<p>变量命名规范：</p>\r\n<ol type=\"1\">\r\n<li>变量名一般用小写字母。</li>\r\n<li>用户自定义的类型一般以大写字母开头。</li>\r\n<li>包含多个单词的标识符，使用驼峰命名法或使用下划线连接不同单词。</li>\r\n<li>当你第一次使用变量再定义它。</li>\r\n</ol>\r\n<p><strong>2.2.4 名字的作用域</strong></p>\r\n<p>花括号以内是作用域。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> {</span><br><span class=\"line\">\t<span class=\"type\">int</span> ival = <span class=\"built_in\">read</span>();</span><br><span class=\"line\">} <span class=\"keyword\">while</span>(ival); <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.3 复合类型</strong></p>\r\n<p>复合类型就是基于其他类型定义的类型，引用和指针是其中两种。</p>\r\n<p>声明语句 = 基本数据类型 + 声明符(类型修饰符(&amp;/*) +\r\n标识符(变量名))</p>\r\n<p><strong>2.3.1 引用</strong></p>\r\n<p>引用是给<strong>对象</strong>起的别名，不能与字面值或表达式绑定。</p>\r\n<p>初始化引用时，是将引用和对象绑定在一起。引用无法重定向，只能一直指向初始值。故引用必须初始化。</p>\r\n<p>对引用的所有操作都是对与之绑定的对象的操作。</p>\r\n<p>引用非对象。不能定义对引用的引用，因为引用非对象。</p>\r\n<p>引用只能绑定同类型对象。</p>\r\n<p><strong>2.3.2 指针</strong></p>\r\n<p>指针存放某个<strong>对象</strong>的地址。</p>\r\n<p>指针必须指向同类型对象。</p>\r\n<p><strong>指针与引用的不同：</strong></p>\r\n<ol type=\"1\">\r\n<li>指针可以不初始化，引用不可以。</li>\r\n<li>指针是一个对象，引用不是。</li>\r\n<li>指针可以重定向，引用不可以。</li>\r\n</ol>\r\n<p>从右向左读比较易于弄清：</p>\r\n<ul>\r\n<li>离变量名最近的符号(&amp;)对变量的类型有最直接的影响，因此 r\r\n是一个引用。</li>\r\n<li>声明符的其余部分用以确定 r 引用的类型是什么，*说明 r\r\n引用的是一个指针。</li>\r\n<li>声明的基本数据类型部分指出 r 引用的是一个int指针。</li>\r\n</ul>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"type\">int</span> *&amp;r = p;</span><br></pre></td></tr></table></figure>\r\n<p><strong>空指针</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 三种定义空指针的方式。最好用第一种</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"type\">int</span> *p = <span class=\"literal\">NULL</span>;    <span class=\"comment\">// NULL 是在头文件 cstdlib 中定义的预处理变量，值为 0。</span></span><br></pre></td></tr></table></figure>\r\n<p>初始化指针，如果不清楚该指向谁，先初始化为 nullptr。</p>\r\n<p><strong>void* 指针</strong></p>\r\n<p>void*\r\n指针是特殊的指针类型，可以存放任意对象的地址。它的用处比较有限，不能直接操作它所指的对象。</p>\r\n<p><strong>2.4 const限定符</strong></p>\r\n<p><strong>const\r\n对象必须初始化</strong>，因为一旦创建就不能再改变值。</p>\r\n<p>默认情况下，const 对象仅在文件内有效。</p>\r\n<p>如果想在多个文件间共享 const 对象，必须在变量的声明和定义前都添加\r\n<strong>extern</strong> 关键字并在本文件中声明。</p>\r\n<p><strong>2.4.1 const的引用</strong></p>\r\n<p>const 引用不能改变引用的对象。</p>\r\n<p>不能用非常量引用指向一个常量对象。可以用常量引用指向一个非常量对象。</p>\r\n<p>当用常量引用绑定一个非常量对象时，不能通过引用改变引用对象的值，但是可以通过其他方式改变值。常量指针也一样。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;r1 = ci; <span class=\"comment\">// 错误，试图让一个非常量引用指向一个常量对象</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;r2 = i; <span class=\"comment\">// 正确，一个常量引用指向一个非常量对象</span></span><br></pre></td></tr></table></figure>\r\n<p>引用的类型必须与其所引用对象的类型一致，但是有一个例外就是初始化常量引用时允许用任意表达式作为初始值（包括常量表达式），只要该表达式结果可以转换为引用的类型。</p>\r\n<p><strong>2.4.2 指针和const</strong></p>\r\n<p>指向常量的指针的用法和常量引用相似，<strong>但是是不一样的。</strong>它既可以指向常量也可以指向非常量，不能改变对象的值。但是非常量对象可以通过其他途径改变值</p>\r\n<p><strong>2.4.3 顶层const</strong></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>顶层 const</th>\r\n<th>底层 const</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>含义</td>\r\n<td>对象本身是个常量</td>\r\n<td>所指的对象是一个常量</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>适用范围</td>\r\n<td>任何数据类型通用</td>\r\n<td>引用和指针</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>初始化</td>\r\n<td>必须</td>\r\n<td>不必须</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>引用实际上只能是底层 const(常量引用)，不存在顶层 const\r\n的引用，因为引用非对象。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;<span class=\"type\">const</span> p2 = p1;<span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\r\n<p>对于指针和引用而言，顶层 const 在右边，底层 const\r\n在左边。对于其他类型，全都是顶层 const</p>\r\n<p>执行对象的拷贝操作时，顶层 const 没有影响，两个对象要有相同的底层\r\nconst 资格。不能将底层 const\r\n拷贝给非常量，反之可以，非常量将会转化为常量。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> i = ci; <span class=\"comment\">// 正确，顶层 const 无影响</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.4.4 constexpr和常量表达式</strong></p>\r\n<p>常量表达式是指<strong>值不会改变</strong>并且<strong>在编译过程就能得到计算结果</strong>的表达式。</p>\r\n<p><strong>字面值属于常量表达式</strong>，由常量表达式初始化的 const\r\n对象也是常量表达式。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">32</span>;          <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> b = a + <span class=\"number\">1</span>;       <span class=\"comment\">// 是常量表达式</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> sz = <span class=\"built_in\">get_size</span>(); <span class=\"comment\">// 不是常量表达式，因为虽然 sz 是常量，但它的具体值等到运行时才知道。</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>cosntexpr变量</strong></p>\r\n<p>由 constexpr 声明的变量必须用常量表达式初始化。</p>\r\n<p>不能用普通函数初始化 constexpr 变量，但可以使用 constexpr 函数初始化\r\nconstexpr 变量。</p>\r\n<p>constexpr int sz = size(); //只有当 size() 是一个 constexpr\r\n函数时这才是一条正确的声明语句。</p>\r\n<p><strong>constexpr 变量是真正的“常量”</strong>，而 const\r\n现在一般只用来表示 <strong>“只读”</strong>。</p>\r\n<p><strong>字面值类型</strong></p>\r\n<p><strong>算术类型、引用、指针、字面值常数类、枚举属于字面值类型</strong>，自定义类、IO\r\n库，string类则不属于。</p>\r\n<p>cosntexpr 指针的初始值必须是 nullptr\r\n或存储于固定地址的对象。函数体之外的对象和静态变量的地址都是固定不变的。</p>\r\n<p><strong>指针和constexpr</strong></p>\r\n<p>注意区分 constexpr 和 const 。constexpr 都是顶层\r\nconst，仅对指针本身有效。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *p = <span class=\"literal\">nullptr</span>;     <span class=\"comment\">// p 是一个指向整型常量的指针</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> *q = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.5 处理类型</strong></p>\r\n<p><strong>2.5.1 类型别名</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">double</span> wages; <span class=\"keyword\">using</span> wages = <span class=\"type\">double</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> wages base, *p; <span class=\"comment\">// base 是 double 的别名，p 是 double* 的别名。</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>指针、常量和类型别名</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">char</span>* pstring; </span><br><span class=\"line\"><span class=\"type\">const</span> pstring cstr = <span class=\"number\">0</span>; <span class=\"comment\">// 是一个指向 char 的常量指针。</span></span><br></pre></td></tr></table></figure>\r\n<p>不能采用直接替换的方式将其理解为 const char* cstr =\r\n0，这是错误的，是一个指向 const char 的指针。</p>\r\n<p>替换前基本数据类型是 char*。</p>\r\n<p>替换后基本数据类型是 const char，*是声明符的一部分。</p>\r\n<p><strong>2.5.2 auto类型说明符</strong></p>\r\n<p>auto\r\n可以在一条语句中声明多个变量，但是多个变量必须是同一个基本数据类型。</p>\r\n<p><strong>复合类型、常量和auto</strong></p>\r\n<p>编译器推断出的 auto\r\n类型有时和初始值并不一样，编译器会进行适当的调整：</p>\r\n<ol type=\"1\">\r\n<li>auto 根据引用来推断类型时会以引用对象的类型作为 auto 的类型。</li>\r\n<li>auto 一般会忽略掉顶层 const，如果希望 auto 是一个顶层\r\nconst，需要明确指出。</li>\r\n<li>设置一个类型为 auto 的引用/指针时，顶层 const 保留。</li>\r\n<li>auto 会保留底层 const。</li>\r\n</ol>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> e = &amp;ci;       <span class=\"comment\">// e是一个指向整数常量的指针(对常量对象取地址是一种底层const)</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span> f = ci;  <span class=\"comment\">// ci的推演类型是int，f是const int (明确指出auto是顶层const)</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;g = ci;       <span class=\"comment\">// g是一个整型常量引用，绑定到ci</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;h = <span class=\"number\">42</span>;       <span class=\"comment\">// 错误:不能为非常量引用绑定字面值</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;j = <span class=\"number\">42</span>; <span class=\"comment\">// 正确:可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>\r\n<p>int 与 int*、int&amp; 是一个基本数据类型，而 const int 与 int\r\n不是一种类型。</p>\r\n<p>用 auto 定义引用时，必须用 &amp; 指明要定义的是引用。</p>\r\n<p><strong>2.5.3 decltype类型指示符</strong></p>\r\n<p>当希望获得表达式的类型但是不要值的时候，可以使用类型说明符\r\ndecltype。</p>\r\n<p>如果 decltype\r\n使用的表达式是一个变量，则它返回该变量的类型（<strong>包括顶层 const\r\n和引用在内</strong>）。</p>\r\n<p>当获得的类型是引用时，必须初始化。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ci = <span class=\"number\">0</span>, &amp;cj = ci;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(ci) x = <span class=\"number\">0</span>;  <span class=\"comment\">// x 的类型是 const int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) y = x;  <span class=\"comment\">// y 的类型是 const int&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(cj) z;      <span class=\"comment\">// z 是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>decltype 和引用</strong></p>\r\n<p>表达式的值类别为<strong>左值</strong>产生 T&amp;\r\n，<strong>右值</strong>产生 T。</p>\r\n<p>左值类型：<strong>解引用指针</strong>，<strong>给变量加括号，赋值操作</strong></p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">42</span>, &amp;r = i, *p;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(r+<span class=\"number\">0</span>) b;      <span class=\"comment\">// b 的类型是 int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(*p) c = i;   <span class=\"comment\">// c 的类型是 int&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>((i)) d = i;  <span class=\"comment\">// d 的类型是 int&amp;</span></span><br></pre></td></tr></table></figure>\r\n<p><strong>2.6 自定义数据结构</strong></p>\r\n<p><strong>2.6.1 定义Sales_data类型</strong></p>\r\n<p>定义类时可以给数据成员提供<strong>类内初始值</strong>以进行初始化。没有类内初始值的成员则被默认初始化。</p>\r\n<p>类内初始值可以放在花括号中或等号的右边，不能使用圆括号。</p>\r\n<p><strong>2.6.3 编写自己的头文件</strong></p>\r\n<p>类通常定义在头文件中，类所在头文件的名字应与类的名字一样。</p>\r\n<p>头文件通常定义那些<strong>只能被定义一次的实体</strong>，比如类、const、constexpr\r\n等。</p>\r\n<p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>\r\n<p><strong>预处理器概述</strong></p>\r\n<p>确保头文件多次包含仍能安全工作的常用技术是预处理器。</p>\r\n<p>预处理变量有两种状态：已定义和未定义。预处理变量的名字全部大写。</p>\r\n<p>整个程序中的预处理变量包括头文件保护符必须唯一，通常基于头文件中类的名字来构建保护符的名字，以确保其唯一性。</p>\r\n<p>c++ 中包含三个头文件保护符：</p>\r\n<ol type=\"1\">\r\n<li>#define：把一个名字设定为预处理变量</li>\r\n<li>#ifdef：当且仅当变量已定义时为真</li>\r\n<li>#ifndef：当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直到遇到\r\n#endif 为止</li>\r\n<li>#endif</li>\r\n</ol>\r\n<p>预处理变量无视作用域的规则，作用范围是文件内。</p>\r\n","categories":["c++"],"tags":["c++ primer"]},{"title":"博客备忘录","url":"/posts/ed1ccd58/","content":"<p>记录博客一些操作和语法。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"section\">.</h2>\r\n<h3 id=\"section-1\">,</h3>\r\n<h4 id=\"section-2\">,</h4>\r\n<h2 id=\"note-标签\">Note 标签</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">{% note %}</span><br><span class=\"line\">default 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note primary %}</span><br><span class=\"line\">primary 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note success %}</span><br><span class=\"line\">success 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note info %}</span><br><span class=\"line\">info 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note warning %}</span><br><span class=\"line\">warning 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br><span class=\"line\"></span><br><span class=\"line\">{% note danger %}</span><br><span class=\"line\">danger 提示块标签</span><br><span class=\"line\">{% endnote %}</span><br></pre></td></tr></table></figure>\r\n<p>效果：</p>\r\n<div class=\"note \"><p>default 提示块标签</p>\r\n</div>\r\n<div class=\"note primary\"><p>primary 提示块标签</p>\r\n</div>\r\n<div class=\"note success\"><p>success 提示块标签</p>\r\n</div>\r\n<div class=\"note info\"><p>info 提示块标签</p>\r\n</div>\r\n<div class=\"note warning\"><p>warning 提示块标签</p>\r\n</div>\r\n<div class=\"note danger\"><p>danger 提示块标签</p>\r\n</div>\r\n","categories":["杂项"],"tags":["博客","test"]}]